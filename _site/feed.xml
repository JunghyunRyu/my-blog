<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/my-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/my-blog/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2025-10-15T01:55:39+09:00</updated><id>http://localhost:4000/my-blog/feed.xml</id><title type="html">AI Quality Lab</title><subtitle>AI 기반 QA 자동화와 테스트 품질 관리에 대한 실무 경험과 기술 트렌드를 공유합니다.</subtitle><author><name>류정현</name><email>jhryu115@gmail.com</email></author><entry><title type="html">Show GN: AutoDev: 바이브 코딩을 자동화해주는 도구</title><link href="http://localhost:4000/my-blog/qa%20engineer/2025/10/15/show-gn-autodev.html" rel="alternate" type="text/html" title="Show GN: AutoDev: 바이브 코딩을 자동화해주는 도구" /><published>2025-10-15T01:53:42+09:00</published><updated>2025-10-15T01:53:42+09:00</updated><id>http://localhost:4000/my-blog/qa%20engineer/2025/10/15/show-gn-autodev</id><content type="html" xml:base="http://localhost:4000/my-blog/qa%20engineer/2025/10/15/show-gn-autodev.html"><![CDATA[<h2 id="요약">요약</h2>

<p>AutoDev는 바이브 코딩을 자동화하여 소프트웨어 개발의 효율성을 크게 향상시키는 도구입니다. 이 도구는 작업을 맡기면 자동으로 PR을 생성하고, CI 실패 및 PR 리뷰를 처리하여 개발자들이 보다 창의적인 작업에 집중할 수 있도록 돕습니다. CompositeTask 기능을 통해 AI는 작업을 의존성 그래프로 분리하여 효율적인 작업 흐름을 제공합니다. 이러한 혁신은 소프트웨어 개발의 속도와 품질을 동시에 개선할 수 있는 가능성을 열어주며, 많은 기업들이 이러한 도구를 도입하여 경쟁력을 강화할 것으로 예상됩니다.</p>

<h2 id="qa-engineer가-알아야-할-핵심-내용">QA Engineer가 알아야 할 핵심 내용</h2>

<ul>
  <li>첫 번째 인사이트: AutoDev와 같은 자동화 도구는 현대 소프트웨어 개발 환경의 복잡성과 속도 증가에 대응하기 위해 필수적입니다. QA 엔지니어는 반복적인 작업에서 벗어나 더 전략적인 품질 향상 활동에 집중할 수 있게 됩니다. 2025년까지 80%의 팀이 AI 기반 도구를 도입할 것으로 예상되며(tricentis.com), 이는 QA 엔지니어에게 경쟁력을 부여하는 중요한 요소가 될 것입니다.</li>
  <li>두 번째 인사이트: AutoDev는 기존 QA 프로세스에 큰 변화를 가져옵니다. 테스트 계획 단계에서 AI가 위험 요소를 분석하여 우선순위를 정하고, 실행 단계에서 자동으로 결함을 탐지하여 분석할 수 있습니다. 이러한 접근은 QAOps 및 shift-left 전략을 통해 품질 보증을 더욱 강화하며, AI는 리스크 식별과 우선순위 재조정에 중요한 역할을 하게 됩니다.</li>
  <li>세 번째 인사이트: QA 업무 수행 시 AI의 결과물을 맹신하지 말고 반드시 검증해야 합니다. AI는 학습 데이터에 기반하므로 특정 도메인 지식이 필요한 경우 부정확한 결과를 초래할 수 있습니다. 또한, 데이터 보안과 프라이버시 문제를 고려해야 하며, AI의 결정 과정이 불투명할 수 있으므로 결과에 대한 추가 검증이 필요합니다. AI는 도구일 뿐이며, 최종 판단은 여전히 인간 전문가에게 있습니다.</li>
</ul>

<h2 id="실무-적용-가이드">실무 적용 가이드</h2>

<h3 id="1-테스트-자동화-개선">1. 테스트 자동화 개선</h3>

<p>AutoDev를 활용하여 테스트 자동화를 고도화하는 방법은 AI 기반 테스트 케이스 자동 생성과 자가 치유 기능을 활용하는 것입니다. 예를 들어, 자연어로 요구사항을 입력하면 AI가 자동으로 테스트 케이스를 생성하고, UI 변경에 대한 자가 치유 기능을 통해 유지보수 부담을 경감할 수 있습니다.</p>

<p><strong>실행 단계:</strong></p>
<ul>
  <li>
    <ol>
      <li>AI 테스트 도구 파일럿 도입: 팀의 작은 모듈에 AI 기반 테스트 케이스 생성 도구(예: ChatGPT)를 시범 적용하여 효과를 검증합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>AI 생성 테스트 검토: AI가 생성한 테스트 케이스를 QA 엔지니어가 검토하여 누락된 시나리오나 오류가 있는 케이스를 걸러냅니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>CI/CD 통합: 검증된 AI 생성 테스트 케이스를 CI/CD 파이프라인에 포함시켜 코드 변경 시 자동 실행되도록 구성합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>결과 모니터링 및 피드백: AI가 제안한 테스트의 실행 결과를 모니터링하고</li>
    </ol>
  </li>
  <li>오탐/미탐 사례를 수집하여 모델 개선이나 추가 테스트 케이스 작성에 반영합니다.</li>
  <li>
    <ol>
      <li>팀 가이드 마련: AI 도구 활용에 대한 모범 사례와 한계를 문서화하여 팀원들과 공유하고</li>
    </ol>
  </li>
  <li>AI 결과에 대한 리뷰 절차를 공식화합니다.</li>
</ul>

<h3 id="2-품질-검증-프로세스">2. 품질 검증 프로세스</h3>

<p>AutoDev와 같은 AI 도구를 품질 검증 프로세스에 통합하여 효율성을 높일 수 있습니다. 테스트 기획 단계에서 AI 분석을 통해 위험도가 높은 기능을 선별하고 자원을 집중하는 전략을 세울 수 있습니다. 테스트 실행 단계에서는 AI가 로그와 결과를 분석하여 결함의 근본 원인을 파악하고, 방대한 테스트 결과를 시각화하여 QA 팀이 쉽게 이해할 수 있도록 돕습니다. 배포 후 운영 단계에서는 AIOps와 연계된 AI 모니터링을 통해 실제 사용자 환경의 이상 징후를 조기 탐지할 수 있습니다. 이러한 접근은 요구사항 분석부터 운영 모니터링까지 QA 프로세스 전반에 AI를 내재화하여 전체 테스트 사이클의 효율성과 선제적 품질 관리 능력을 향상시킵니다.</p>

<h2 id="학습-로드맵">학습 로드맵</h2>

<h3 id="즉시-학습-1-2주">즉시 학습 (1-2주)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>기술의 기본 개념과 작동 원리 이해</li>
  <li>간단한 도구나 플랫폼 사용 경험 쌓기 (초보자 수준)</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>Tricentis 블로그: 5 AI Trends Shaping Software Testing 2025</li>
  <li>Test Automation University - Visual AI 테스트 과정</li>
</ul>

<h3 id="단기-학습-1-3개월">단기 학습 (1-3개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>머신러닝 및 데이터 과학 기초 지식 (Python 등 프로그래밍 언어 활용)</li>
  <li>관련 테스트 자동화 프레임워크 및 도구 심화 학습</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>ISTQB AI Testing 자격증 자료 및 교육과정 (공식 Syllabus, 샘플 시험)</li>
  <li>온라인 강좌: AI in Software Testing (실습 위주 튜토리얼)</li>
</ul>

<h3 id="장기-학습-3-6개월">장기 학습 (3-6개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>AI 모델 커스터마이징 및 현장 적용 능력 (예: 결함 예측 모델 개발)</li>
  <li>AI 품질 거버넌스 및 윤리 준수 방안 습득</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>전문 서적: AI와 소프트웨어 테스팅</li>
  <li>AI Testing 포럼, QA 콘퍼런스</li>
</ul>

<h2 id="전문가-의견">전문가 의견</h2>

<h3 id="시니어-qa-엔지니어-관점">시니어 QA 엔지니어 관점</h3>

<blockquote>
  <p>AutoDev와 같은 기술의 도입은 품질 보증의 기본 원리를 변화시키지 않습니다. 오히려 이 기술을 ‘똑똑한 보조자’로 활용하여 반복적인 테스트 처리를 기술이 담당하게 함으로써, QA 엔지니어는 초기 설계 단계의 품질 이슈 검토나 창의적인 테스트 시나리오 구상에 더 많은 시간을 투자할 수 있습니다. 그러나 기술 결과물에 대한 최종 책임은 여전히 QA 팀에 있으며, 놓친 부분을 찾아내고 판단을 보완하는 역할이 중요합니다.</p>
</blockquote>

<h3 id="테스트-자동화-전문가-관점">테스트 자동화 전문가 관점</h3>

<blockquote>
  <p>AutoDev는 테스트 자동화 분야에 큰 변화를 가져왔습니다. 과거에는 스크립트 작성과 유지보수에 많은 수작업 시간이 소요되었으나, 이제 기술이 코드 생성부터 자가 치유까지 도와주어 자동화 범위가 크게 넓어졌습니다. 특히 시각적 테스트나 동적 요소 식별 기술이 그동안 자동화가 어려웠던 영역을 크게 개선하였으며, 이러한 도구들을 기존 프레임워크와 프로세스에 잘 통합하여 신뢰성 높은 자동화 파이프라인을 구축하는 것이 중요합니다.</p>
</blockquote>

<h3 id="devopssre-관점">DevOps/SRE 관점</h3>

<blockquote>
  <p>AutoDev의 도입으로 개발, 테스트, 운영 간 경계가 더욱 모호해지고 있습니다. 테스트 단계에서 결함을 잘 잡아내면 운영 환경 장애를 줄일 수 있으며, 운영 중 로그 분석으로 이상 징후를 실시간 감지할 수 있는 장점이 있습니다. 그러나 파이프라인에 새로운 복잡성이 생기므로, 기술로부터 나오는 알림과 지표를 기존 모니터링 시스템과 통합하며 오탐지나 경미한 이슈가 과도한 알람으로 이어지지 않도록 튜닝하는 노력이 필요합니다.</p>
</blockquote>

<h2 id="주요-qa">주요 Q&amp;A</h2>

<p><strong>Q:</strong> 이 기술의 핵심 변화는 무엇인가요?</p>

<p><strong>A:</strong> AutoDev는 QA 업무에 깊숙이 도입되어 테스트 케이스 설계, 유지보수, 결함 탐지와 같은 작업들을 지능적으로 자동화할 수 있게 되었습니다. 과거에는 수작업으로 작성하던 시나리오를 요구사항 분석을 통해 대량으로 생성하고, 실행 중 오류를 자가 치유로 자동 수정할 수 있습니다. 그 결과, 훨씬 짧은 시간에 더 폭넓은 테스트를 수행하여 품질을 확보할 수 있으며, QA 인력은 전략 수립과 창의적 품질 향상에 집중할 수 있게 됩니다. 이러한 변화는 많은 기업들이 AI 기반 도구를 도입하여 경쟁력을 강화하는 데 기여하고 있습니다.</p>

<p><strong>Q:</strong> QA 담당자가 확인해야 할 위험 요소는?</p>

<p><strong>A:</strong> AutoDev와 같은 AI 도구를 사용할 때 몇 가지 위험 요소를 고려해야 합니다. 첫째, 기술의 한계로 인해 잘못된 결과가 나올 수 있으며, 학습된 데이터에만 기반하므로 특정 도메인 지식이 필요한 경우 부정확한 테스트 케이스를 제안하거나 중요한 시나리오를 놓칠 수 있습니다. 둘째, 기술에 대한 과도한 의존은 위험하므로 제공된 답이 맥락에 맞는지 판단하고 교차 검증해야 하며, 이를 소홀히 하면 잘못된 결론을 얻을 수 있습니다. 셋째, 데이터 보안과 프라이버시 문제도 고려해야 하며, 외부 클라우드 서비스에 민감한 테스트 데이터를 업로드하면 정보 유출 위험이 있습니다. 넷째, 기술의 결정은 이유가 불투명할 때가 많으므로 결과를 맹신하기보다 왜 그런 결과가 나왔는지 추가 확인하는 태도가 필요합니다.</p>

<p><strong>Q:</strong> 팀에 바로 적용할 수 있는 행동 항목은?</p>

<p><strong>A:</strong> 팀에서는 AutoDev와 같은 기술을 즉시 적용하기 위해 작은 범위에서 파일럿을 시작하는 것이 좋습니다. 현재 프로젝트의 일부 모듈에 관련 도구를 도입해 운영하고 그 결과를 팀과 공유하세요. 또한, 팀원들의 이해도를 높이기 위해 짧은 워크숍이나 스터디를 개최하여 간단한 실습을 해볼 수 있습니다. 즉각 실행할 수 있는 조치로, 기술이 제안한 결과에 대해 항상 2인 이상의 리뷰를 거치는 절차를 추가하여 실수를 걸러내고 팀의 신뢰도를 유지할 수 있도록 하세요.</p>

<h2 id="follow-up-제안">Follow-up 제안</h2>

<ul>
  <li>생성형 AI를 활용한 테스트 데이터 및 시나리오 생성 기법 연구</li>
  <li>Agentic AI (자율 에이전트) 기술의 QA 분야 적용 가능성 모니터링</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://www.istqb.org/downloads/category/2-syllabi.html">ISTQB 생성형 AI 테스팅 Syllabus v1.0</a></li>
  <li><a href="https://www.practitest.com/resource-center/blog/chatgpt-prompts-for-software-testing/">ChatGPT를 활용한 테스트 자동화 가이드 (PractiTest 블로그)</a></li>
</ul>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="QA Engineer" /><category term="GeekNews" /><category term="QA" /><category term="AI" /><category term="Development" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">미국은 공장 붐 대신 AI 골드러시를 맞이하고 있음 ⭐⭐⭐</title><link href="http://localhost:4000/my-blog/qa%20engineer/2025/10/15/ai.html" rel="alternate" type="text/html" title="미국은 공장 붐 대신 AI 골드러시를 맞이하고 있음 ⭐⭐⭐" /><published>2025-10-15T00:22:22+09:00</published><updated>2025-10-15T00:22:22+09:00</updated><id>http://localhost:4000/my-blog/qa%20engineer/2025/10/15/ai</id><content type="html" xml:base="http://localhost:4000/my-blog/qa%20engineer/2025/10/15/ai.html"><![CDATA[<h2 id="요약">요약</h2>

<p>미국 경제에서 AI 산업이 하드웨어 제조업을 대체하며 주도적인 역할을 하고 있습니다. 많은 자본이 전통적인 공장 설립 대신 인공지능 개발 및 데이터센터에 유입되고 있으며, 이는 고용 증가와 함께 새로운 기술 트렌드를 형성하고 있습니다. AI의 발전은 기업들이 경쟁력을 유지하고 혁신을 이루는 데 필수적인 요소로 자리잡고 있습니다.</p>

<h2 id="qa-engineer가-알아야-할-핵심-내용">QA Engineer가 알아야 할 핵심 내용</h2>

<ul>
  <li>AI 기술의 발전은 현대 소프트웨어 개발 환경의 복잡성과 속도 증가에 대응하기 위한 필수적인 도구로 자리잡고 있습니다. QA 엔지니어는 AI를 활용하여 테스트 케이스를 자동으로 생성하고, 결함을 예측하며, 품질 보증 프로세스를 효율적으로 개선할 수 있습니다. 2025년까지 80%의 소프트웨어 팀이 AI를 도입할 것으로 예상되며(tricentis.com), 이는 QA 엔지니어에게 경쟁력을 높이는 중요한 요소가 될 것입니다.</li>
  <li>AI의 도입은 기존 QA 프로세스에 큰 변화를 가져옵니다. 테스트 계획 단계에서 AI가 위험 요소를 분석하여 우선적으로 테스트할 기능을 선정하고, 실행 단계에서는 AI가 로그를 분석하여 결함의 근본 원인을 파악하는 데 도움을 줍니다. 이러한 변화는 QAOps와 같은 새로운 접근법을 통해 리스크 식별과 우선순위 재조정에 기여하며, 데이터 중심 접근 방식이 QA 품질을 향상시키는 데 중요한 역할을 합니다.</li>
  <li>AI 기술을 활용할 때는 몇 가지 주의사항이 필요합니다. AI의 결과물을 맹신하지 말고 반드시 검증해야 하며, 학습 데이터의 한계로 인해 발생할 수 있는 오작동 가능성을 인지해야 합니다. 또한, 보안 및 개인정보 보호 측면에서 테스트 데이터의 클라우드 유출 위험을 고려하고, AI는 도구일 뿐이라는 점을 명심해야 합니다.</li>
</ul>

<h2 id="실무-적용-가이드">실무 적용 가이드</h2>

<h3 id="1-테스트-자동화-개선">1. 테스트 자동화 개선</h3>

<p>AI를 활용하여 테스트 자동화를 고도화하는 방법으로는 AI 기반 테스트 케이스 자동 생성, 자연어 요구사항 입력을 통한 테스트 생성, 자가 치유 기능을 활용한 UI 변경 대응 등이 있습니다. 이러한 접근은 유지보수 부담을 경감하고, 테스트 커버리지를 넓히는 데 기여할 수 있습니다.</p>

<p><strong>실행 단계:</strong></p>
<ul>
  <li>
    <ol>
      <li>AI 테스트 도구 파일럿 도입: 팀의 작은 모듈에 AI 기반 테스트 케이스 생성 도구(예: ChatGPT)를 시범 적용하여 효과를 검증합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>AI 생성 테스트 검토: AI가 생성한 테스트 케이스를 QA 엔지니어가 검토하여 누락된 시나리오나 오류가 있는 케이스를 걸러냅니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>CI/CD 통합: 검증된 AI 생성 테스트 케이스를 CI/CD 파이프라인에 포함시켜 코드 변경 시 자동 실행되도록 구성합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>결과 모니터링 및 피드백: AI가 제안한 테스트의 실행 결과를 모니터링하고</li>
    </ol>
  </li>
  <li>오탐/미탐 사례를 수집하여 모델 개선이나 추가 테스트 케이스 작성에 반영합니다.</li>
  <li>
    <ol>
      <li>팀 가이드 마련: AI 도구 활용에 대한 모범 사례와 한계를 문서화하여 팀원들과 공유하고</li>
    </ol>
  </li>
  <li>AI 결과에 대한 리뷰 절차를 공식화합니다.</li>
</ul>

<h3 id="2-품질-검증-프로세스">2. 품질 검증 프로세스</h3>

<p>AI를 품질 검증 프로세스 전반에 통합하기 위해서는 테스트 기획 단계에서 AI 분석을 통해 위험도가 높은 기능을 선별하고 자원을 집중하는 전략이 필요합니다. 테스트 실행 단계에서는 AI가 로그와 결과를 분석하여 결함의 근본 원인을 파악하거나 방대한 테스트 결과를 시각화하는 방법을 활용할 수 있습니다. 배포 후 운영 단계에서는 AIOps와 연계된 AI 모니터링을 통해 실제 사용자 환경의 이상 징후를 조기 탐지하는 방안을 마련해야 합니다. 이러한 접근은 요구사항 분석부터 운영 모니터링까지 QA 프로세스 각 단계에 AI를 내재화하여 전체 테스트 사이클의 효율성과 선제적 품질 관리 능력을 향상시키는 데 기여합니다.</p>

<h2 id="학습-로드맵">학습 로드맵</h2>

<h3 id="즉시-학습-1-2주">즉시 학습 (1-2주)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>기술의 기본 개념과 작동 원리 이해</li>
  <li>간단한 도구나 플랫폼 사용 경험 쌓기 (초보자 수준)</li>
</ul>

<h3 id="단기-학습-1-3개월">단기 학습 (1-3개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>머신러닝 및 데이터 과학 기초 지식 (Python 등 프로그래밍 언어 활용)</li>
  <li>관련 테스트 자동화 프레임워크 및 도구 심화 학습</li>
</ul>

<h3 id="장기-학습-3-6개월">장기 학습 (3-6개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>AI 모델 커스터마이징 및 현장 적용 능력 (예: 결함 예측 모델 개발)</li>
  <li>AI 품질 거버넌스 및 윤리 준수 방안 습득</li>
</ul>

<h2 id="전문가-의견">전문가 의견</h2>

<h3 id="시니어-qa-엔지니어-관점">시니어 QA 엔지니어 관점</h3>

<blockquote>
  <p>AI 기술의 도입은 품질 보증의 기본 원리를 변화시키지 않으며, 이를 ‘똑똑한 보조자’로 보는 것이 중요합니다. 반복적인 테스트 처리를 AI가 담당함으로써 QA 엔지니어는 초기 설계 단계의 품질 이슈 검토나 창의적인 테스트 시나리오 구상에 더 많은 시간을 할애할 수 있습니다. 그러나 기술 결과물에 대한 최종 책임은 여전히 QA 팀에 있으므로, 놓친 부분을 찾아내고 판단을 보완하는 역할이 중요합니다.</p>
</blockquote>

<h3 id="테스트-자동화-전문가-관점">테스트 자동화 전문가 관점</h3>

<blockquote>
  <p>AI 기술은 자동화 분야에 혁신적인 변화를 가져왔습니다. 과거에는 스크립트 작성과 유지보수에 많은 수작업 시간이 소요되었으나, 이제 AI가 코드 생성부터 자가 치유까지 도와주어 자동화 범위가 크게 넓어졌습니다. 특히 시각적 테스트나 동적 요소 식별 기술이 그동안 자동화가 어려웠던 영역을 크게 개선하였으며, 이러한 도구들을 기존 프레임워크와 프로세스에 잘 통합하여 신뢰성 높은 자동화 파이프라인을 구축하는 것이 중요합니다.</p>
</blockquote>

<h3 id="devopssre-관점">DevOps/SRE 관점</h3>

<blockquote>
  <p>AI 기술의 도입은 개발, 테스트, 운영 간 경계를 더욱 모호하게 만들고 있습니다. 테스트 단계에서 결함을 잘 잡아내면 운영 환경 장애를 줄일 수 있으며, 운영 중 로그 분석으로 이상 징후를 실시간 감지할 수 있는 장점이 있습니다. 그러나 파이프라인에 새로운 복잡성이 생기며, AI로부터 나오는 알림과 지표를 기존 모니터링 시스템과 통합하여 오탐지나 경미한 이슈가 과도한 알람으로 이어지지 않도록 튜닝하는 노력이 필요합니다.</p>
</blockquote>

<h2 id="주요-qa">주요 Q&amp;A</h2>

<p><strong>Q:</strong> 이 기술의 핵심 변화는 무엇인가요?</p>

<p><strong>A:</strong> AI 기술의 도입은 QA 업무에 깊숙이 자리잡으면서 테스트 케이스 설계, 유지보수, 결함 탐지와 같은 작업들을 지능적으로 자동화할 수 있게 되었습니다. 과거에는 수작업으로 작성하던 시나리오를 이제 요구사항 분석을 통해 대량으로 생성하고, 실행 중 오류를 자가 치유로 자동 수정할 수 있게 되었습니다. 그 결과, 훨씬 짧은 시간에 더 폭넓은 테스트를 수행하여 품질을 확보할 수 있으며, QA 인력은 전략 수립과 창의적 품질 향상에 집중할 수 있게 되었습니다. 업계 통계에 따르면, AI 도구를 활용한 팀의 테스트 커버리지는 평균 30% 증가했습니다(tricentis.com).</p>

<p><strong>Q:</strong> QA 담당자가 확인해야 할 위험 요소는?</p>

<p><strong>A:</strong> AI 기술을 활용할 때는 여러 위험 요소를 고려해야 합니다. 첫째, 기술의 한계로 인해 잘못된 결과가 나올 수 있으며, 학습된 데이터에만 기반하므로 특정 도메인 지식이 필요한 경우 부정확한 테스트 케이스를 제안하거나 중요한 시나리오를 놓칠 수 있습니다. 둘째, 기술에 대한 과도한 의존은 위험하므로 제공된 답이 맥락에 맞는지 판단하고 교차 검증해야 하며, 이를 소홀히 하면 잘못된 결론을 얻을 수 있습니다. 셋째, 기술 도구 사용 시 데이터 보안과 프라이버시 문제도 고려해야 하며, 외부 클라우드 서비스에 제품의 민감한 테스트 데이터를 업로드하면 정보 유출 위험이 있습니다. 넷째, 기술의 결정은 이유가 불투명할 때가 많으므로(설명 가능성 낮음) 결과를 맹신하기보다 왜 그런 결과가 나왔는지 추가 확인하는 태도가 필요합니다.</p>

<p><strong>Q:</strong> 팀에 바로 적용할 수 있는 행동 항목은?</p>

<p><strong>A:</strong> 팀은 즉시 실행 가능한 구체적인 액션 아이템을 마련해야 합니다. 우선 작은 범위에서라도 AI 기술 활용을 시작해보는 것이 좋으며, 현재 프로젝트의 일부 모듈에 관련 도구를 도입해 파일럿으로 운영하고 그 결과를 팀과 공유해야 합니다. 또한 팀원들의 이해도를 높이기 위해 짧은 워크숍이나 스터디를 개최하여 간단한 실습(예: 도구로 테스트 시나리오 만들어보기)을 해볼 수 있습니다. 마지막으로, 기술이 제안한 결과에 대해 항상 2인 이상의 리뷰를 거치는 절차를 추가하여 실수를 걸러내고 팀의 신뢰도를 유지할 수 있도록 해야 합니다.</p>

<h2 id="follow-up-제안">Follow-up 제안</h2>

<ul>
  <li>생성형 AI를 활용한 테스트 데이터 및 시나리오 생성 기법 연구</li>
  <li>Agentic AI (자율 에이전트) 기술의 QA 분야 적용 가능성 모니터링</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://www.istqb.org/downloads/category/2-advanced-level-documents.html">ISTQB 생성형 AI 테스팅 Syllabus v1.0</a></li>
  <li><a href="https://www.practitest.com/resource-center/blog/chatgpt-prompts-for-software-testing/">ChatGPT를 활용한 테스트 자동화 가이드 (PractiTest 블로그)</a></li>
</ul>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="QA Engineer" /><category term="AI" /><category term="Development" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">Show GN: AI 마피아 게임</title><link href="http://localhost:4000/my-blog/daily%20life/2025/10/14/show-gn-ai.html" rel="alternate" type="text/html" title="Show GN: AI 마피아 게임" /><published>2025-10-14T16:50:57+09:00</published><updated>2025-10-14T16:50:57+09:00</updated><id>http://localhost:4000/my-blog/daily%20life/2025/10/14/show-gn-ai</id><content type="html" xml:base="http://localhost:4000/my-blog/daily%20life/2025/10/14/show-gn-ai.html"><![CDATA[<h2 id="요약">요약</h2>

<p>AI 기반의 마피아 게임은 12명 중 11명이 AI로 구성된 혁신적인 게임으로, 사용자에게 다양한 경험을 제공합니다. 이 게임은 순한맛과 매운맛의 내용 선택이 가능하며, ElevenLabs의 음성 모드를 통해 더욱 몰입감 있는 플레이가 가능합니다. 특히, 매운맛 모드에서는 AI가 욕설을 포함한 대사를 생성하여 유머와 긴장감을 동시에 제공합니다. 이러한 기술은 게임 산업에서 AI의 활용 가능성을 보여주며, 사용자 경험을 극대화하는 방향으로 발전하고 있습니다.</p>

<h2 id="qa-engineer가-알아야-할-핵심-내용">QA Engineer가 알아야 할 핵심 내용</h2>

<ul>
  <li>AI 기술의 도입은 QA 엔지니어에게 필수적인 도구가 되고 있습니다. 현대 소프트웨어 개발 환경은 복잡성과 속도가 증가하고 있으며, 2025년까지 80%의 팀이 AI를 활용할 것으로 예상됩니다(tricentis.com). 이러한 변화는 QA 프로세스의 효율성을 높이고, 반복적인 작업에서 엔지니어가 전략적이고 창의적인 업무에 집중할 수 있도록 돕습니다.</li>
  <li>AI 기술은 기존 QA 프로세스에 큰 변화를 가져오고 있습니다. 테스트 계획, 실행, 분석 단계에서 AI가 데이터를 분석하고 결함을 예측함으로써 리스크 식별과 우선순위 재조정이 용이해집니다. QAOps와 shift-left 접근법을 통해 초기 단계에서 품질을 보장할 수 있으며, 데이터 중심 접근이 가능해집니다.</li>
  <li>QA 업무 수행 시 AI의 결과물을 맹신하지 말고 반드시 검증해야 합니다. AI는 학습 데이터의 한계로 인해 오작동할 수 있으며, 인간 전문가의 검토와 승인 절차가 필수적입니다. 또한, 보안 및 개인정보 보호 측면에서도 위험이 존재하므로, 테스트 데이터의 안전한 관리가 중요합니다.</li>
</ul>

<h2 id="실무-적용-가이드">실무 적용 가이드</h2>

<h3 id="1-테스트-자동화-개선">1. 테스트 자동화 개선</h3>

<p>AI를 활용하여 테스트 자동화를 고도화할 수 있습니다. 예를 들어, AI 기반 도구를 사용하여 자연어로 작성된 요구사항에서 테스트 케이스를 자동 생성하고, UI 변경에 대한 자가 치유 기능을 활용하여 유지보수 부담을 경감할 수 있습니다.</p>

<p><strong>실행 단계:</strong></p>
<ul>
  <li>
    <ol>
      <li>AI 테스트 도구 파일럿 도입: 팀의 작은 모듈에 AI 기반 테스트 케이스 생성 도구(예: ChatGPT)를 시범 적용하여 효과를 검증합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>AI 생성 테스트 검토: AI가 생성한 테스트 케이스를 QA 엔지니어가 검토하여 누락된 시나리오나 오류가 있는 케이스를 걸러냅니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>CI/CD 통합: 검증된 AI 생성 테스트 케이스를 CI/CD 파이프라인에 포함시켜 코드 변경 시 자동 실행되도록 구성합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>결과 모니터링 및 피드백: AI가 제안한 테스트의 실행 결과를 모니터링하고</li>
    </ol>
  </li>
  <li>오탐/미탐 사례를 수집하여 모델 개선이나 추가 테스트 케이스 작성에 반영합니다.</li>
  <li>
    <ol>
      <li>팀 가이드 마련: AI 도구 활용에 대한 모범 사례와 한계를 문서화하여 팀원들과 공유하고</li>
    </ol>
  </li>
  <li>AI 결과에 대한 리뷰 절차를 공식화합니다.</li>
</ul>

<h3 id="2-품질-검증-프로세스">2. 품질 검증 프로세스</h3>

<p>AI를 품질 검증 프로세스 전반에 통합하기 위해, 테스트 기획 단계에서 AI 분석을 통해 위험도가 높은 기능을 선별하고 자원을 집중하는 전략을 수립할 수 있습니다. 테스트 실행 단계에서는 AI가 로그와 결과를 분석하여 결함의 근본 원인을 파악하고, 방대한 테스트 결과를 시각화하여 QA 팀이 보다 효과적으로 의사 결정을 내릴 수 있도록 지원합니다. 배포 후 운영 단계에서는 AIOps와 연계된 AI 모니터링을 통해 실제 사용자 환경의 이상 징후를 조기 탐지하여, 전체 테스트 사이클의 효율성과 선제적 품질 관리 능력을 향상시킬 수 있습니다.</p>

<h2 id="학습-로드맵">학습 로드맵</h2>

<h3 id="즉시-학습-1-2주">즉시 학습 (1-2주)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>기술의 기본 개념과 작동 원리 이해</li>
  <li>간단한 도구나 플랫폼 사용 경험 쌓기 (초보자 수준)</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>Tricentis 블로그: 5 AI Trends Shaping Software Testing 2025</li>
  <li>Test Automation University - Visual AI 테스트 과정</li>
</ul>

<h3 id="단기-학습-1-3개월">단기 학습 (1-3개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>머신러닝 및 데이터 과학 기초 지식 (Python 등 프로그래밍 언어 활용)</li>
  <li>관련 테스트 자동화 프레임워크 및 도구 심화 학습</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>ISTQB AI Testing 자격증 자료 및 교육과정 (공식 Syllabus, 샘플 시험)</li>
  <li>온라인 강좌: AI in Software Testing (실습 위주 튜토리얼)</li>
</ul>

<h3 id="장기-학습-3-6개월">장기 학습 (3-6개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>AI 모델 커스터마이징 및 현장 적용 능력 (예: 결함 예측 모델 개발)</li>
  <li>AI 품질 거버넌스 및 윤리 준수 방안 습득</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>전문 서적: AI와 소프트웨어 테스팅</li>
  <li>AI Testing 포럼, QA 콘퍼런스</li>
</ul>

<h2 id="전문가-의견">전문가 의견</h2>

<h3 id="시니어-qa-엔지니어-관점">시니어 QA 엔지니어 관점</h3>

<blockquote>
  <p>AI 기술의 도입은 품질 보증의 기본 원리를 변화시키지 않으며, 이를 ‘똑똑한 보조자’로 보는 것이 중요합니다. 반복적인 테스트 처리를 AI가 담당함으로써 QA 엔지니어는 초기 설계 단계에서 품질 이슈를 검토하거나 창의적인 테스트 시나리오 구상에 더 많은 시간을 투자할 수 있습니다. 그러나 기술 결과물에 대한 최종 책임은 여전히 QA 팀에 있으므로, 놓친 부분을 찾아내고 판단을 보완하는 역할이 중요합니다.</p>
</blockquote>

<h3 id="테스트-자동화-전문가-관점">테스트 자동화 전문가 관점</h3>

<blockquote>
  <p>AI 기술은 자동화 분야에 큰 변화를 가져왔습니다. 과거에는 스크립트 작성과 유지보수에 많은 수작업 시간이 들었으나, 이제 AI가 코드 생성부터 자가 치유까지 도와주어 자동화 범위가 크게 넓어졌습니다. 특히, 시각적 테스트나 동적 요소 식별 기술이 그동안 자동화가 어려웠던 영역을 크게 개선하였으며, 이러한 도구들을 기존 프레임워크와 프로세스에 잘 통합하여 신뢰성 높은 자동화 파이프라인을 구축하는 것이 중요합니다.</p>
</blockquote>

<h3 id="devopssre-관점">DevOps/SRE 관점</h3>

<blockquote>
  <p>AI 기술의 도입은 개발, 테스트, 운영 간 경계를 더욱 모호하게 만들고 있습니다. 테스트 단계에서 결함을 잘 잡아내면 운영 환경 장애를 줄일 수 있으며, 운영 중 로그 분석으로 이상 징후를 실시간 감지할 수 있는 장점이 있습니다. 그러나 새로운 복잡성이 생기고, 기술로부터 나오는 알림과 지표를 기존 모니터링 시스템과 통합하여 오탐지나 경미한 이슈가 과도한 알람으로 이어지지 않도록 튜닝하는 노력이 필요합니다.</p>
</blockquote>

<h2 id="주요-qa">주요 Q&amp;A</h2>

<p><strong>Q:</strong> 이 기술의 핵심 변화는 무엇인가요?</p>

<p><strong>A:</strong> AI 기술의 도입은 QA 업무에 깊숙이 들어오면서 테스트 케이스 설계, 유지보수, 결함 탐지와 같은 작업들을 지능적으로 자동화할 수 있게 되었습니다. 과거에는 수작업으로 작성하던 시나리오를 이제는 요구사항 분석을 통해 대량으로 생성할 수 있으며, 실행 중 오류를 자가 치유로 자동 수정할 수 있습니다. 이로 인해 QA 인력은 전략 수립과 창의적 품질 향상에 집중할 수 있게 되며, 결과적으로 훨씬 짧은 시간에 더 폭넓은 테스트를 수행하여 품질을 확보할 수 있습니다. 예를 들어, AI가 수초 내에 수백 개의 시나리오를 만들어내어 테스트 커버리지를 넓혀줍니다.</p>

<p><strong>Q:</strong> QA 담당자가 확인해야 할 위험 요소는?</p>

<p><strong>A:</strong> AI 기술의 도입에는 여러 위험 요소가 존재합니다. 첫째, AI의 한계로 인해 잘못된 결과가 나올 수 있으며, 학습된 데이터에만 기반하므로 특정 도메인 지식이 필요한 경우 부정확한 테스트 케이스를 제안하거나 중요한 시나리오를 놓칠 수 있습니다. 둘째, AI에 대한 과도한 의존은 위험하므로 제공된 답이 맥락에 맞는지 판단하고 교차 검증해야 합니다. 셋째, 데이터 보안과 프라이버시 문제도 고려해야 하며, 외부 클라우드 서비스에 민감한 테스트 데이터를 업로드할 경우 정보 유출 위험이 있습니다. 넷째, AI의 결정은 이유가 불투명할 때가 많으므로 결과를 맹신하기보다 왜 그런 결과가 나왔는지 추가 확인하는 태도가 필요합니다.</p>

<p><strong>Q:</strong> 팀에 바로 적용할 수 있는 행동 항목은?</p>

<p><strong>A:</strong> 팀은 즉시 실행 가능한 구체적인 액션 아이템을 마련해야 합니다. 우선 작은 범위에서라도 AI 기술 활용을 시작해보는 것이 좋으며, 현재 프로젝트의 일부 모듈에 관련 도구를 도입해 파일럿으로 운영하고 그 결과를 팀과 공유해야 합니다. 또한 팀원들의 이해도를 높이기 위해 짧은 워크숍이나 스터디를 개최하여 간단한 실습을 해볼 수 있습니다. 마지막으로, AI가 제안한 결과에 대해 항상 2인 이상의 리뷰를 거치는 절차를 추가하여 실수를 걸러내고 팀의 신뢰도를 유지할 수 있도록 해야 합니다.</p>

<h2 id="follow-up-제안">Follow-up 제안</h2>

<ul>
  <li>생성형 AI를 활용한 테스트 데이터 및 시나리오 생성 기법 연구</li>
  <li>Agentic AI (자율 에이전트) 기술의 QA 분야 적용 가능성 모니터링</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://www.istqb.org/downloads/category/2-advanced-level-documents.html">ISTQB 생성형 AI 테스팅 Syllabus v1.0</a></li>
  <li><a href="https://www.practitest.com/resource-center/blog/chatgpt-prompts-for-software-testing/">ChatGPT를 활용한 테스트 자동화 가이드 (PractiTest 블로그)</a></li>
</ul>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="Daily Life" /><category term="GeekNews" /><category term="QA" /><category term="AI" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">Wi-Fi 속도가 빠를수록 품질이 나빠지는 이유 ⭐⭐⭐</title><link href="http://localhost:4000/my-blog/qa%20engineer/2025/10/12/wi-fi.html" rel="alternate" type="text/html" title="Wi-Fi 속도가 빠를수록 품질이 나빠지는 이유 ⭐⭐⭐" /><published>2025-10-12T17:41:41+09:00</published><updated>2025-10-12T17:41:41+09:00</updated><id>http://localhost:4000/my-blog/qa%20engineer/2025/10/12/wi-fi</id><content type="html" xml:base="http://localhost:4000/my-blog/qa%20engineer/2025/10/12/wi-fi.html"><![CDATA[<h2 id="요약">요약</h2>

<p>Wi-Fi 속도가 빠를수록 품질이 나빠지는 현상은 5 GHz 대역에서의 넓은 채널 폭 사용으로 인해 발생하는 간섭과 지연 증가에 기인합니다. 소비자용 제품들은 기본적으로 80MHz 이상의 넓은 채널 폭을 설정하여 최상의 경험을 제공하기보다는 성능 저하를 초래할 수 있습니다. 이러한 기술적 이해는 QA 엔지니어가 네트워크 성능 테스트를 설계하고 실행하는 데 중요한 요소로 작용할 수 있습니다.</p>

<h2 id="qa-engineer가-알아야-할-핵심-내용">QA Engineer가 알아야 할 핵심 내용</h2>

<ul>
  <li>현대 소프트웨어 개발 환경에서는 빠른 속도와 높은 품질을 동시에 요구받고 있습니다. Wi-Fi 속도와 품질 간의 상관관계를 이해하는 것은 QA 엔지니어에게 필수적입니다. 특히, 네트워크 성능이 소프트웨어 품질에 미치는 영향을 고려할 때, 2025년까지 80%의 팀이 AI 기반 테스트 도구를 도입할 것으로 예상되는 만큼, 이러한 기술적 이해는 경쟁력을 높이는 데 중요한 역할을 할 것입니다.</li>
  <li>기존 QA 프로세스에서 네트워크 성능 테스트는 종종 간과되기 쉽습니다. 그러나 Wi-Fi 속도와 품질의 상관관계를 이해함으로써 테스트 계획 및 실행 단계에서 보다 정교한 접근이 가능해집니다. 예를 들어, ‘shift-left’ 접근법을 통해 초기 개발 단계에서부터 성능 테스트를 통합하고, AI를 활용하여 리스크를 식별하고 우선순위를 재조정하는 것이 중요합니다.</li>
  <li>QA 업무 수행 시, Wi-Fi 속도와 품질 간의 관계를 간과하지 않는 것이 중요합니다. AI 결과물에 대한 검증이 필수적이며, 학습 데이터의 한계로 인해 발생할 수 있는 오작동 가능성을 항상 염두에 두어야 합니다. 또한, 테스트 데이터의 보안과 개인정보 보호 측면에서도 주의가 필요하며, AI는 도구일 뿐이라는 점을 명심해야 합니다.</li>
</ul>

<h2 id="실무-적용-가이드">실무 적용 가이드</h2>

<h3 id="1-테스트-자동화-개선">1. 테스트 자동화 개선</h3>

<p>Wi-Fi 성능 테스트를 자동화하기 위해 AI 기반 도구를 활용하여 테스트 케이스를 생성하고, 네트워크 성능을 모니터링하는 방안을 제시합니다. 예를 들어, AI가 생성한 테스트 케이스를 통해 다양한 네트워크 환경에서의 성능을 검증하고, 자가 치유 기능을 통해 발생하는 문제를 자동으로 수정할 수 있습니다.</p>

<p><strong>실행 단계:</strong></p>
<ul>
  <li>
    <ol>
      <li>AI 테스트 도구 파일럿 도입: 팀의 작은 모듈에 AI 기반 테스트 케이스 생성 도구(예: ChatGPT)를 시범 적용하여 효과를 검증합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>AI 생성 테스트 검토: AI가 생성한 테스트 케이스를 QA 엔지니어가 검토하여 누락된 시나리오나 오류가 있는 케이스를 걸러냅니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>CI/CD 통합: 검증된 AI 생성 테스트 케이스를 CI/CD 파이프라인에 포함시켜 코드 변경 시 자동 실행되도록 구성합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>결과 모니터링 및 피드백: AI가 제안한 테스트의 실행 결과를 모니터링하고</li>
    </ol>
  </li>
  <li>오탐/미탐 사례를 수집하여 모델 개선이나 추가 테스트 케이스 작성에 반영합니다.</li>
  <li>
    <ol>
      <li>팀 가이드 마련: AI 도구 활용에 대한 모범 사례와 한계를 문서화하여 팀원들과 공유하고</li>
    </ol>
  </li>
  <li>AI 결과에 대한 리뷰 절차를 공식화합니다.</li>
</ul>

<h3 id="2-품질-검증-프로세스">2. 품질 검증 프로세스</h3>

<p>AI를 품질 검증 프로세스 전반에 통합하기 위한 종합적인 가이드를 작성합니다. 테스트 기획 단계에서 AI 분석을 통해 위험도가 높은 기능을 선별하고 자원을 집중하는 전략, 테스트 실행 단계에서 AI가 로그와 결과를 분석하여 결함의 근본 원인을 파악하거나 방대한 테스트 결과를 시각화하는 방법, 배포 후 운영 단계에서 AIOps와 연계된 AI 모니터링을 통해 실제 사용자 환경의 이상 징후를 조기 탐지하는 방안을 포함합니다. 요구사항 분석부터 운영 모니터링까지 QA 프로세스 각 단계에 AI를 내재화하여 전체 테스트 사이클의 효율성과 선제적 품질 관리 능력을 향상시키는 방법을 제시합니다.</p>

<h2 id="학습-로드맵">학습 로드맵</h2>

<h3 id="즉시-학습-1-2주">즉시 학습 (1-2주)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>Wi-Fi 기술의 기본 개념과 작동 원리 이해</li>
  <li>간단한 네트워크 성능 테스트 도구 사용 경험 쌓기 (초보자 수준)</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>관련 블로그 포스트나 공식 문서 (예: ‘Wi-Fi 성능 최적화 가이드 - Cisco’)</li>
  <li>무료 온라인 코스나 튜토리얼 (예: ‘Coursera - Networking Basics’)</li>
</ul>

<h3 id="단기-학습-1-3개월">단기 학습 (1-3개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>네트워크 성능 측정 및 분석 기초 지식</li>
  <li>관련 테스트 자동화 프레임워크 및 도구 심화 학습</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>전문 자격증 교육과정 및 자료 (예: ‘Cisco CCNA 자격증 과정’)</li>
  <li>실습 위주 온라인 강좌나 워크샵 (예: ‘Udemy - Wi-Fi 성능 테스트 및 최적화’)</li>
</ul>

<h3 id="장기-학습-3-6개월">장기 학습 (3-6개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>AI 기반 네트워크 성능 분석 및 최적화 능력</li>
  <li>AI 품질 거버넌스 및 윤리 준수 방안 습득</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>전문 서적이나 심층 기술 자료 (예: ‘Wi-Fi 성능 최적화 및 테스트’)</li>
  <li>국제 컨퍼런스 및 커뮤니티 참여 (예: ‘IEEE Wireless Communications and Networking Conference’)</li>
</ul>

<h2 id="전문가-의견">전문가 의견</h2>

<h3 id="시니어-qa-엔지니어-관점">시니어 QA 엔지니어 관점</h3>

<blockquote>
  <p>Wi-Fi 성능과 품질 간의 관계를 이해하는 것은 QA 엔지니어에게 필수적입니다. 기술 도입으로 품질 보증의 기본 원리는 변하지 않으며, 이 기술을 ‘똑똑한 보조자’로 보는 시각이 중요합니다. 반복적인 테스트 처리를 기술이 담당함으로써 초기 설계 단계의 품질 이슈 검토나 창의적인 테스트 시나리오 구상에 시간을 투입할 수 있게 되었습니다. 그러나 기술 결과물에 대한 최종 책임은 여전히 QA 팀에 있으므로 놓친 부분을 찾아내고 판단을 보완하는 역할의 중요성을 강조합니다.</p>
</blockquote>

<h3 id="테스트-자동화-전문가-관점">테스트 자동화 전문가 관점</h3>

<blockquote>
  <p>Wi-Fi 성능 테스트 자동화 분야에서 AI 기술의 도입은 큰 변화를 가져왔습니다. 과거 스크립트 작성과 유지보수에 많은 수작업 시간이 들었으나, 이제 기술이 코드 생성부터 자가 치유까지 도와주어 자동화 범위가 크게 넓어졌습니다. 특히, 네트워크 성능 테스트에서 AI가 제공하는 데이터 분석 기능은 기존의 수작업 방식보다 훨씬 효율적입니다. 이러한 도구들을 기존 프레임워크와 프로세스에 잘 통합하여 신뢰성 높은 자동화 파이프라인을 구축하는 것이 중요합니다.</p>
</blockquote>

<h3 id="devopssre-관점">DevOps/SRE 관점</h3>

<blockquote>
  <p>Wi-Fi 성능과 품질 간의 관계를 이해하는 것은 운영 및 안정성 관점에서도 중요합니다. 기술 도입으로 개발, 테스트, 운영 간 경계가 더욱 모호해지는 추세입니다. 테스트 단계에서 결함을 잘 잡아내면 운영 환경 장애를 줄일 수 있으며, 운영 중 로그 분석으로 이상 징후를 실시간 감지할 수 있는 장점이 있습니다. 그러나 파이프라인에 새로운 복잡성이 생기므로, 기술로부터 나오는 알림과 지표를 기존 모니터링 시스템과 통합하며 오탐지나 경미한 이슈가 과도한 알람으로 이어지지 않도록 튜닝하는 노력이 필요합니다.</p>
</blockquote>

<h2 id="주요-qa">주요 Q&amp;A</h2>

<p><strong>Q:</strong> 이 기술의 핵심 변화는 무엇인가요?</p>

<p><strong>A:</strong> Wi-Fi 성능과 품질 간의 관계를 이해함으로써 QA 업무에 큰 변화가 생겼습니다. 과거에는 수작업으로 테스트 케이스를 작성하던 방식에서 벗어나, AI를 활용하여 요구사항 분석을 통해 대량으로 테스트 케이스를 생성하고, 실행 중 오류를 자가 치유로 자동 수정할 수 있게 되었습니다. 이러한 변화는 훨씬 짧은 시간에 더 폭넓은 테스트를 수행하여 품질을 확보할 수 있게 하며, QA 인력은 전략 수립과 창의적 품질 향상에 집중할 수 있게 됩니다. 예를 들어, AI 기반 도구를 활용한 테스트 자동화가 이러한 변화를 이끌고 있습니다.</p>

<p><strong>Q:</strong> QA 담당자가 확인해야 할 위험 요소는?</p>

<p><strong>A:</strong> Wi-Fi 성능 테스트와 관련하여 여러 위험 요소가 존재합니다. 첫째, 기술의 한계로 인해 잘못된 결과가 나올 수 있으며, 학습된 데이터에만 기반하므로 특정 도메인 지식이 필요한 경우 부정확한 테스트 케이스를 제안하거나 중요한 시나리오를 놓칠 수 있습니다. 둘째, 기술에 대한 과도한 의존은 위험하므로 제공된 답이 맥락에 맞는지 판단하고 교차 검증해야 하며, 이를 소홀히 하면 잘못된 결론을 얻을 수 있습니다. 셋째, 데이터 보안과 프라이버시 문제도 고려해야 하며, 외부 클라우드 서비스에 민감한 테스트 데이터를 업로드하면 정보 유출 위험이 있습니다. 넷째, 기술의 결정은 이유가 불투명할 때가 많으므로 결과를 맹신하기보다 왜 그런 결과가 나왔는지 추가 확인하는 태도가 필요합니다.</p>

<p><strong>Q:</strong> 팀에 바로 적용할 수 있는 행동 항목은?</p>

<p><strong>A:</strong> 팀은 즉시 실행 가능한 구체적인 액션 아이템을 마련해야 합니다. 우선 작은 범위에서라도 Wi-Fi 성능 테스트 도구를 도입해 파일럿으로 운영하고 그 결과를 팀과 공유하는 것이 좋습니다. 또한 팀원들의 이해도를 높이기 위해 짧은 워크숍이나 스터디를 개최하여 간단한 실습을 해볼 수 있습니다. 즉각 실행할 수 있는 조치로, AI가 제안한 결과에 대해 항상 2인 이상의 리뷰를 거치는 절차를 추가하여 실수를 걸러내고 팀의 신뢰도를 유지할 수 있도록 해야 합니다.</p>

<h2 id="follow-up-제안">Follow-up 제안</h2>

<ul>
  <li>Wi-Fi 성능 최적화 기법 연구</li>
  <li>AI 기반 네트워크 성능 분석 도구의 발전 동향</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://www.cisco.com/c/en/us/solutions/small-business/resource-center/wifi-performance-optimization.html">Wi-Fi 성능 최적화 가이드</a></li>
  <li><a href="https://www.coursera.org/learn/networking-basics">Coursera - Networking Basics</a></li>
</ul>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="QA Engineer" /><category term="QA" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">“튜토리얼 지옥”을 대체한 “바이브 코딩 지옥”의 등장 ⭐⭐⭐</title><link href="http://localhost:4000/my-blog/qa%20engineer/2025/10/12/geeknews.html" rel="alternate" type="text/html" title="“튜토리얼 지옥”을 대체한 “바이브 코딩 지옥”의 등장 ⭐⭐⭐" /><published>2025-10-12T17:00:05+09:00</published><updated>2025-10-12T17:00:05+09:00</updated><id>http://localhost:4000/my-blog/qa%20engineer/2025/10/12/geeknews</id><content type="html" xml:base="http://localhost:4000/my-blog/qa%20engineer/2025/10/12/geeknews.html"><![CDATA[<h2 id="요약">요약</h2>

<p>최근 코딩 교육 환경에서 ‘튜토리얼 지옥’ 대신 ‘바이브 코딩 지옥’이 새로운 문제로 대두되고 있습니다. 이는 AI 없이는 코딩할 수 없고, AI가 생성한 코드에 의존하게 되는 상황을 의미합니다. 이러한 변화는 QA 엔지니어에게도 큰 영향을 미치며, AI 도구를 활용한 테스트 자동화와 품질 보증의 새로운 접근법이 필요해지고 있습니다. AI의 도입은 소프트웨어 개발 및 테스트 프로세스의 효율성을 높일 수 있지만, 동시에 새로운 리스크와 과제를 동반합니다.</p>

<h2 id="qa-engineer가-알아야-할-핵심-내용">QA Engineer가 알아야 할 핵심 내용</h2>

<ul>
  <li>QA 엔지니어에게 AI 도구의 도입은 현대 소프트웨어 개발 환경의 복잡성과 속도 증가에 대응하기 위한 필수적인 요소가 되고 있습니다. 특히, AI가 제공하는 자동화 기능은 반복적인 테스트 작업을 줄여주고, QA 팀이 더 전략적이고 창의적인 업무에 집중할 수 있도록 돕습니다. 2025년까지 80%의 팀이 AI를 활용할 것이라는 전망이 있는 만큼, QA 엔지니어는 이러한 도구를 적극적으로 도입하여 경쟁력을 유지해야 합니다.</li>
  <li>AI의 도입은 기존 QA 프로세스에 큰 변화를 가져옵니다. 테스트 계획 단계에서 AI가 위험도를 분석하여 자원을 집중할 기능을 선별하고, 실행 단계에서는 AI가 로그와 결과를 분석하여 결함의 근본 원인을 파악하는 데 도움을 줍니다. 이러한 변화는 QAOps와 shift-left 접근법을 통해 더욱 강화되며, AI는 리스크 식별과 우선순위 재조정에 중요한 역할을 할 것입니다.</li>
  <li>AI 도구를 활용할 때 주의해야 할 점은 AI 결과물을 맹신하지 않고 반드시 검증해야 한다는 것입니다. AI의 학습 데이터에 기반한 오작동 가능성, 인간 전문가의 검토와 승인 절차의 중요성, 그리고 보안 및 개인정보 보호 측면의 위험을 고려해야 합니다. AI는 도구일 뿐이며, 최종 판단은 여전히 QA 팀의 몫임을 잊지 말아야 합니다.</li>
</ul>

<h2 id="실무-적용-가이드">실무 적용 가이드</h2>

<h3 id="1-테스트-자동화-개선">1. 테스트 자동화 개선</h3>

<p>AI 도구를 활용하여 테스트 자동화를 고도화할 수 있습니다. 예를 들어, AI 기반 도구를 통해 테스트 케이스를 자동 생성하고, 자가 치유 기능을 활용하여 UI 변경에 즉각 대응할 수 있습니다.</p>

<p><strong>실행 단계:</strong></p>
<ul>
  <li>
    <ol>
      <li>AI 테스트 도구 파일럿 도입: 팀의 작은 모듈에 AI 기반 테스트 케이스 생성 도구(예: ChatGPT)를 시범 적용하여 효과를 검증합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>AI 생성 테스트 검토: AI가 생성한 테스트 케이스를 QA 엔지니어가 검토하여 누락된 시나리오나 오류가 있는 케이스를 걸러냅니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>CI/CD 통합: 검증된 AI 생성 테스트 케이스를 CI/CD 파이프라인에 포함시켜 코드 변경 시 자동 실행되도록 구성합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>결과 모니터링 및 피드백: AI가 제안한 테스트의 실행 결과를 모니터링하고</li>
    </ol>
  </li>
  <li>오탐/미탐 사례를 수집하여 모델 개선이나 추가 테스트 케이스 작성에 반영합니다.</li>
  <li>
    <ol>
      <li>팀 가이드 마련: AI 도구 활용에 대한 모범 사례와 한계를 문서화하여 팀원들과 공유하고</li>
    </ol>
  </li>
  <li>AI 결과에 대한 리뷰 절차를 공식화합니다.</li>
</ul>

<h3 id="2-품질-검증-프로세스">2. 품질 검증 프로세스</h3>

<p>AI를 품질 검증 프로세스 전반에 통합하기 위한 종합적인 가이드를 제시합니다. 테스트 기획 단계에서 AI 분석을 통해 위험도가 높은 기능을 선별하고 자원을 집중하는 전략을 세울 수 있습니다. 테스트 실행 단계에서는 AI가 로그와 결과를 분석하여 결함의 근본 원인을 파악하거나 방대한 테스트 결과를 시각화하는 방법을 활용할 수 있습니다. 배포 후 운영 단계에서는 AIOps와 연계된 AI 모니터링을 통해 실제 사용자 환경의 이상 징후를 조기 탐지하는 방안을 마련할 수 있습니다. 이러한 접근은 요구사항 분석부터 운영 모니터링까지 QA 프로세스 각 단계에 AI를 내재화하여 전체 테스트 사이클의 효율성과 선제적 품질 관리 능력을 향상시킵니다.</p>

<h2 id="학습-로드맵">학습 로드맵</h2>

<h3 id="즉시-학습-1-2주">즉시 학습 (1-2주)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>기술의 기본 개념과 작동 원리 이해</li>
  <li>간단한 도구나 플랫폼 사용 경험 쌓기 (초보자 수준)</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>Tricentis 블로그: 5 AI Trends Shaping Software Testing 2025</li>
  <li>Test Automation University - Visual AI 테스트 과정</li>
</ul>

<h3 id="단기-학습-1-3개월">단기 학습 (1-3개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>머신러닝 및 데이터 과학 기초 지식 (Python 등 프로그래밍 언어 활용)</li>
  <li>관련 테스트 자동화 프레임워크 및 도구 심화 학습</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>ISTQB AI Testing 자격증 자료 및 교육과정 (공식 Syllabus, 샘플 시험)</li>
  <li>온라인 강좌: AI in Software Testing (실습 위주 튜토리얼)</li>
</ul>

<h3 id="장기-학습-3-6개월">장기 학습 (3-6개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>AI 모델 커스터마이징 및 현장 적용 능력 (예: 결함 예측 모델 개발)</li>
  <li>AI 품질 거버넌스 및 윤리 준수 방안 습득</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>전문 서적: AI와 소프트웨어 테스팅</li>
  <li>AI Testing 포럼, QA 콘퍼런스</li>
</ul>

<h2 id="전문가-의견">전문가 의견</h2>

<h3 id="시니어-qa-엔지니어-관점">시니어 QA 엔지니어 관점</h3>

<blockquote>
  <p>시니어 QA 엔지니어 관점에서 AI 도구의 도입은 품질 보증의 기본 원리를 변하지 않게 하면서도, QA 팀의 역할을 변화시키고 있습니다. AI는 반복적인 테스트 처리를 담당하게 되어, QA 팀은 초기 설계 단계의 품질 이슈 검토나 창의적인 테스트 시나리오 구상에 더 많은 시간을 투자할 수 있게 됩니다. 그러나 기술 결과물에 대한 최종 책임은 여전히 QA 팀에 있으므로, 놓친 부분을 찾아내고 판단을 보완하는 역할이 중요합니다.</p>
</blockquote>

<h3 id="테스트-자동화-전문가-관점">테스트 자동화 전문가 관점</h3>

<blockquote>
  <p>테스트 자동화 전문가 입장에서 AI 도구는 자동화 분야에 혁신을 가져왔습니다. 과거에는 스크립트 작성과 유지보수에 많은 수작업 시간이 소요되었으나, 이제 AI는 코드 생성부터 자가 치유까지 도와주어 자동화 범위가 크게 넓어졌습니다. 특히, 시각적 테스트나 동적 요소 식별 기술이 그동안 자동화가 어려웠던 영역을 크게 개선했습니다. 이러한 도구들을 기존 프레임워크와 프로세스에 잘 통합하여 신뢰성 높은 자동화 파이프라인을 구축하는 것이 중요합니다.</p>
</blockquote>

<h3 id="devopssre-관점">DevOps/SRE 관점</h3>

<blockquote>
  <p>운영 및 안정성 관점에서 AI 도구의 도입은 개발, 테스트, 운영 간 경계가 더욱 모호해지는 추세를 가져왔습니다. 테스트 단계에서 결함을 잘 잡아내면 운영 환경 장애를 줄일 수 있으며, 운영 중 로그 분석으로 이상 징후를 실시간 감지할 수 있는 장점이 있습니다. 그러나 파이프라인에 새로운 복잡성이 생기며, AI로부터 나오는 알림과 지표를 기존 모니터링 시스템과 통합하여 오탐지나 경미한 이슈가 과도한 알람으로 이어지지 않도록 튜닝하는 노력이 필요합니다.</p>
</blockquote>

<h2 id="주요-qa">주요 Q&amp;A</h2>

<p><strong>Q:</strong> 이 기술의 핵심 변화는 무엇인가요?</p>

<p><strong>A:</strong> AI 도구의 도입은 QA 업무에 큰 변화를 가져왔습니다. 과거에는 수작업으로 작성하던 테스트 케이스를 이제 AI가 요구사항 분석을 통해 대량으로 생성할 수 있게 되었습니다. 또한, 실행 중 오류를 자가 치유로 자동 수정할 수 있어, 훨씬 짧은 시간에 더 폭넓은 테스트를 수행할 수 있습니다. 이로 인해 QA 인력은 전략 수립과 창의적 품질 향상에 집중할 수 있게 되었습니다. 업계 통계에 따르면, AI 도구를 활용한 팀은 테스트 커버리지가 30% 이상 향상되었다고 보고되고 있습니다.</p>

<p><strong>Q:</strong> QA 담당자가 확인해야 할 위험 요소는?</p>

<p><strong>A:</strong> AI 도구를 사용할 때 여러 위험 요소를 고려해야 합니다. 첫째, AI의 한계로 인해 잘못된 결과가 나올 수 있으며, 특정 도메인 지식이 필요한 경우 부정확한 테스트 케이스를 제안하거나 중요한 시나리오를 놓칠 수 있습니다. 둘째, AI에 대한 과도한 의존은 위험하므로 제공된 답이 맥락에 맞는지 판단하고 교차 검증해야 합니다. 셋째, 데이터 보안과 프라이버시 문제도 고려해야 하며, 외부 클라우드 서비스에 민감한 테스트 데이터를 업로드하면 정보 유출 위험이 있습니다. 넷째, AI의 결정은 이유가 불투명할 때가 많으므로 결과를 맹신하기보다 왜 그런 결과가 나왔는지 추가 확인하는 태도가 필요합니다.</p>

<p><strong>Q:</strong> 팀에 바로 적용할 수 있는 행동 항목은?</p>

<p><strong>A:</strong> 팀은 즉시 실행 가능한 액션 아이템으로, 작은 범위에서라도 AI 도구 활용을 시작하는 것이 좋습니다. 현재 프로젝트의 일부 모듈에 관련 도구를 도입해 파일럿으로 운영하고 그 결과를 팀과 공유하세요. 또한, 팀원들의 이해도를 높이기 위해 짧은 워크숍이나 스터디를 개최하여 간단한 실습을 해볼 수 있습니다. 마지막으로, AI가 제안한 결과에 대해 항상 2인 이상의 리뷰를 거치는 절차를 추가하여 실수를 걸러내고 팀의 신뢰도를 유지할 수 있도록 하세요.</p>

<h2 id="follow-up-제안">Follow-up 제안</h2>

<ul>
  <li>생성형 AI를 활용한 테스트 데이터 및 시나리오 생성 기법 연구</li>
  <li>Agentic AI (자율 에이전트) 기술의 QA 분야 적용 가능성 모니터링</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://www.istqb.org/downloads/category/2-syllabi.html">ISTQB 생성형 AI 테스팅 Syllabus v1.0</a></li>
  <li><a href="https://www.practitest.com/resource-center/blog/chatgpt-prompts-for-software-testing/">ChatGPT를 활용한 테스트 자동화 가이드 (PractiTest 블로그)</a></li>
</ul>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="QA Engineer" /><category term="AI" /><category term="Development" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">EC2 서버에 Nginx와 Application Server(uvicorn/FastAPI) 연결 설정, 운영 팁까지</title><link href="http://localhost:4000/my-blog/learning/2025/10/12/ec2-nginx-applcation.html" rel="alternate" type="text/html" title="EC2 서버에 Nginx와 Application Server(uvicorn/FastAPI) 연결 설정, 운영 팁까지" /><published>2025-10-12T13:05:00+09:00</published><updated>2025-10-12T13:05:00+09:00</updated><id>http://localhost:4000/my-blog/learning/2025/10/12/ec2-nginx-applcation</id><content type="html" xml:base="http://localhost:4000/my-blog/learning/2025/10/12/ec2-nginx-applcation.html"><![CDATA[<h1 id="ec2-서버에-nginx와-application-server-연결-설정-운영-팁까지">EC2 서버에 Nginx와 Application Server 연결 설정, 운영 팁까지</h1>

<p><strong>목표</strong>: AWS EC2(Ubuntu)에서 <strong>FastAPI(Uvicorn)</strong> 애플리케이션을 구동하고, <strong>Nginx</strong>를 리버스 프록시로 앞단에 세워 80 포트로 서비스합니다.</p>

<p>추가로 재부팅 후 자동 기동(<strong>systemd</strong>), 정적 파일 서빙, VSCode <strong>SFTP 배포</strong>, <strong>네트워크 이슈/Windows 경로 이스케이프</strong> 등 운영 관점의 디테일까지 다룹니다.</p>

<hr />

<h2 id="-목차">📋 목차</h2>

<ol>
  <li><a href="#1-아키텍처-개요">아키텍처 개요</a></li>
  <li><a href="#2-선행-준비요약">선행 준비</a></li>
  <li><a href="#3-애플리케이션-코드">애플리케이션 코드</a></li>
  <li><a href="#4-부팅-시-자동-실행systemd">부팅 시 자동 실행</a></li>
  <li><a href="#5-nginx-리버스-프록시-설정">Nginx 리버스 프록시 설정</a></li>
  <li><a href="#6-정적-파일-배치">정적 파일 배치</a></li>
  <li><a href="#7-vscode-sftp로-배포-자동화">VSCode SFTP 배포</a></li>
  <li><a href="#8-운영-체크리스트--트러블슈팅">운영 체크리스트 &amp; 트러블슈팅</a></li>
  <li><a href="#9-https선택--곧바로-운영-반영-시-권장">HTTPS 설정</a></li>
  <li><a href="#10-최종-점검-시나리오">최종 점검</a></li>
</ol>

<hr />

<h2 id="1-아키텍처-개요">1) 아키텍처 개요</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Client] → (80/tcp) → [Nginx on EC2]
                         │
                         └──(127.0.0.1:8000)→ [Uvicorn(FastAPI)]
</code></pre></div></div>

<h3 id="주요-특징">주요 특징</h3>

<ul>
  <li><strong>외부 접근</strong>: 클라이언트는 <strong>80 포트</strong>로 접속 → Nginx가 수신</li>
  <li><strong>내부 라우팅</strong>: Nginx가 내부 루프백(127.0.0.1:8000)으로 Uvicorn에 프록시</li>
  <li><strong>정적 파일</strong>: <code class="language-plaintext highlighter-rouge">/images/</code> 경로는 Nginx가 <strong>직접 서빙</strong> (애플리케이션 서버 우회로 성능 향상)</li>
  <li><strong>자동 기동</strong>: 애플리케이션은 <strong>systemd</strong>로 관리되어 서버 재부팅 시 자동 실행</li>
  <li><strong>보안</strong>: 애플리케이션 서버(8000 포트)는 외부에 노출되지 않음</li>
</ul>

<hr />

<h2 id="2-선행-준비요약">2) 선행 준비(요약)</h2>

<h3 id="ec2-인스턴스-생성-및-접속">EC2 인스턴스 생성 및 접속</h3>

<p><strong>인스턴스 설정</strong></p>
<ul>
  <li><strong>AMI</strong>: Ubuntu 24.04 LTS (또는 22.04 LTS)</li>
  <li><strong>인스턴스 타입</strong>: t2.micro 이상 (프리티어: t2.micro)</li>
  <li><strong>키 페어</strong>: 새로 생성하거나 기존 키 사용 (반드시 <code class="language-plaintext highlighter-rouge">.pem</code> 파일 안전하게 보관)</li>
</ul>

<p><strong>보안 그룹 인바운드 규칙</strong></p>

<table>
  <thead>
    <tr>
      <th>포트</th>
      <th>프로토콜</th>
      <th>소스</th>
      <th>용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>22</td>
      <td>TCP</td>
      <td>0.0.0.0/0</td>
      <td>SSH 접속</td>
    </tr>
    <tr>
      <td>80</td>
      <td>TCP</td>
      <td>0.0.0.0/0</td>
      <td>HTTP 웹 서비스</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>⚠️ <strong>주의</strong>: 8000 포트는 외부에 열지 마세요. Nginx를 통해서만 접근하도록 합니다.</p>
</blockquote>

<p><strong>SSH 접속</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Linux/Mac</span>
ssh <span class="nt">-i</span> /경로/키.pem ubuntu@&lt;EC2_Public_IP&gt;

<span class="c"># Windows (PowerShell)</span>
ssh <span class="nt">-i</span> C:<span class="se">\경</span>로<span class="se">\키</span>.pem ubuntu@&lt;EC2_Public_IP&gt;
</code></pre></div></div>

<h3 id="python-환경-구성">Python 환경 구성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 시스템 업데이트</span>
<span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt upgrade <span class="nt">-y</span>

<span class="c"># Python 및 가상환경 도구 설치</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> python3 python3-venv python3-pip

<span class="c"># 프로젝트 디렉토리 생성</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> ~/reactbase <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ~/reactbase

<span class="c"># 가상환경 생성 및 활성화</span>
python3 <span class="nt">-m</span> venv venv
<span class="nb">source </span>venv/bin/activate

<span class="c"># 필수 패키지 설치</span>
pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip
pip <span class="nb">install </span>fastapi uvicorn[standard]
</code></pre></div></div>

<blockquote>
  <p>💡 <strong>Tip</strong>: <code class="language-plaintext highlighter-rouge">uvicorn[standard]</code>로 설치하면 websocket, HTTP/2 등 추가 기능을 사용할 수 있습니다.</p>
</blockquote>

<hr />

<h2 id="3-애플리케이션-코드">3) 애플리케이션 코드</h2>

<h3 id="fastapi-애플리케이션-작성">FastAPI 애플리케이션 작성</h3>

<p><code class="language-plaintext highlighter-rouge">~/reactbase/server.py</code> 파일을 생성합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
<span class="kn">from</span> <span class="n">fastapi.responses</span> <span class="kn">import</span> <span class="n">PlainTextResponse</span>
<span class="kn">from</span> <span class="n">fastapi.staticfiles</span> <span class="kn">import</span> <span class="n">StaticFiles</span>
<span class="kn">import</span> <span class="n">uvicorn</span>
<span class="kn">import</span> <span class="n">pathlib</span>

<span class="n">app</span> <span class="o">=</span> <span class="nc">FastAPI</span><span class="p">(</span>
    <span class="n">title</span><span class="o">=</span><span class="sh">"</span><span class="s">My API Server</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">EC2에서 구동되는 FastAPI 애플리케이션</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="sh">"</span><span class="s">1.0.0</span><span class="sh">"</span>
<span class="p">)</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">PlainTextResponse</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read_root</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">루트 엔드포인트</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">welcome</span><span class="sh">"</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/hello</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">PlainTextResponse</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read_hello</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Hello 엔드포인트</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">hello</span><span class="sh">"</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/world</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">PlainTextResponse</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read_world</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">World 엔드포인트</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">world</span><span class="sh">"</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/health</span><span class="sh">"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">health_check</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">헬스 체크 엔드포인트 (모니터링용)</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">status</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">healthy</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">service</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">fastapi</span><span class="sh">"</span><span class="p">}</span>

<span class="c1"># 정적 파일: /home/ubuntu/reactbase/public → /images 경로로 노출
</span><span class="n">static_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="p">.</span><span class="nc">Path</span><span class="p">(</span><span class="n">__file__</span><span class="p">).</span><span class="nf">resolve</span><span class="p">().</span><span class="n">parent</span>
<span class="n">public_dir</span> <span class="o">=</span> <span class="n">static_dir</span> <span class="o">/</span> <span class="sh">"</span><span class="s">public</span><span class="sh">"</span>

<span class="c1"># public 디렉토리가 없으면 생성
</span><span class="n">public_dir</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># 정적 파일 마운트
</span><span class="n">app</span><span class="p">.</span><span class="nf">mount</span><span class="p">(</span><span class="sh">"</span><span class="s">/images</span><span class="sh">"</span><span class="p">,</span> <span class="nc">StaticFiles</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="nf">str</span><span class="p">(</span><span class="n">public_dir</span><span class="p">),</span> <span class="n">html</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">images</span><span class="sh">"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">uvicorn</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="sh">"</span><span class="s">0.0.0.0</span><span class="sh">"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="로컬-테스트">로컬 테스트</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 가상환경 활성화 (아직 안 했다면)</span>
<span class="nb">source </span>venv/bin/activate

<span class="c"># 방법 1: Python 직접 실행</span>
python3 server.py

<span class="c"># 방법 2: uvicorn 명령어로 실행 (권장)</span>
uvicorn server:app <span class="nt">--host</span> 0.0.0.0 <span class="nt">--port</span> 8000 <span class="nt">--reload</span>
</code></pre></div></div>

<blockquote>
  <p>💡 <strong>Tip</strong>: <code class="language-plaintext highlighter-rouge">--reload</code> 옵션은 코드 변경 시 자동 재시작합니다 (개발 환경에서만 사용).</p>
</blockquote>

<h3 id="동작-확인">동작 확인</h3>

<p><strong>EC2 서버 내부에서 테스트:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 엔드포인트 테스트</span>
curl http://127.0.0.1:8000/
curl http://127.0.0.1:8000/hello
curl http://127.0.0.1:8000/world

<span class="c"># 헬스 체크</span>
curl http://127.0.0.1:8000/health

<span class="c"># API 문서 확인 (FastAPI 자동 생성)</span>
curl http://127.0.0.1:8000/docs
</code></pre></div></div>

<p><strong>외부에서 테스트 (보안 그룹에 8000 포트가 열려있는 경우만):</strong></p>

<p>브라우저에서 <code class="language-plaintext highlighter-rouge">http://&lt;EC2_Public_IP&gt;:8000/</code> 접속 → <code class="language-plaintext highlighter-rouge">"welcome"</code> 확인</p>

<blockquote>
  <p>⚠️ <strong>주의</strong>: 보안 그룹 인바운드에서 8000 포트를 열지 않았다면 외부 접속은 안 됩니다.</p>

  <p>이것이 정상입니다! Nginx 설정 후에는 80 포트로만 접근하게 됩니다.</p>
</blockquote>

<hr />

<h2 id="4-부팅-시-자동-실행systemd">4) 부팅 시 자동 실행(systemd)</h2>

<p>서버가 재부팅되더라도 애플리케이션이 자동으로 시작되도록 systemd 서비스를 설정합니다.</p>

<h3 id="systemd-서비스-파일-생성">systemd 서비스 파일 생성</h3>

<p><code class="language-plaintext highlighter-rouge">/etc/systemd/system/fastapi.service</code> 파일을 생성합니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/systemd/system/fastapi.service
</code></pre></div></div>

<p>아래 내용을 입력:</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[Unit]</span><span class="w">
</span><span class="py">Description</span><span class="p">=</span><span class="s">FastAPI Application Service</span>
<span class="py">After</span><span class="p">=</span><span class="s">network.target</span>
<span class="py">Documentation</span><span class="p">=</span><span class="s">https://fastapi.tiangolo.com/</span>
<span class="w">
</span><span class="nn">[Service]</span><span class="w">
</span><span class="py">Type</span><span class="p">=</span><span class="s">simple</span>
<span class="py">User</span><span class="p">=</span><span class="s">ubuntu</span>
<span class="py">Group</span><span class="p">=</span><span class="s">ubuntu</span>
<span class="py">WorkingDirectory</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase</span>
<span class="py">Environment</span><span class="p">=</span><span class="s">"PATH=/home/ubuntu/reactbase/venv/bin"</span>
<span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app </span><span class="se">\
</span><span class="w">    </span><span class="s">--host 0.0.0.0 </span><span class="se">\
</span><span class="w">    </span><span class="s">--port 8000 </span><span class="se">\
</span><span class="w">    </span><span class="s">--proxy-headers </span><span class="se">\
</span><span class="w">    </span><span class="s">--forwarded-allow-ips="*"</span>
<span class="w">
</span><span class="c"># 재시작 정책
</span><span class="py">Restart</span><span class="p">=</span><span class="s">always</span>
<span class="py">RestartSec</span><span class="p">=</span><span class="s">3</span>
<span class="w">
</span><span class="c"># 프로세스 종료 시간 제한
</span><span class="py">TimeoutStopSec</span><span class="p">=</span><span class="s">10</span>
<span class="w">
</span><span class="c"># 로그 설정 (journalctl로 확인 가능)
</span><span class="py">StandardOutput</span><span class="p">=</span><span class="s">journal</span>
<span class="py">StandardError</span><span class="p">=</span><span class="s">journal</span>
<span class="py">SyslogIdentifier</span><span class="p">=</span><span class="s">fastapi</span>
<span class="w">
</span><span class="nn">[Install]</span><span class="w">
</span><span class="py">WantedBy</span><span class="p">=</span><span class="s">multi-user.target</span>
</code></pre></div></div>

<h3 id="설정-항목-설명">설정 항목 설명</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">After=network.target</code></td>
      <td>네트워크가 준비된 후에 시작</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">User=ubuntu</code></td>
      <td>ubuntu 사용자 권한으로 실행</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">WorkingDirectory</code></td>
      <td>애플리케이션 실행 디렉토리</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--proxy-headers</code></td>
      <td>Nginx 프록시 헤더 신뢰 (클라이언트 실제 IP 확인)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--forwarded-allow-ips="*"</code></td>
      <td>모든 프록시에서 forwarded 헤더 허용</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Restart=always</code></td>
      <td>실패 시 항상 재시작</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RestartSec=3</code></td>
      <td>재시작 전 3초 대기</td>
    </tr>
  </tbody>
</table>

<h3 id="서비스-활성화-및-시작">서비스 활성화 및 시작</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># systemd 데몬 리로드 (새 서비스 파일 인식)</span>
<span class="nb">sudo </span>systemctl daemon-reload

<span class="c"># 부팅 시 자동 시작 활성화</span>
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>fastapi.service

<span class="c"># 서비스 시작</span>
<span class="nb">sudo </span>systemctl start fastapi.service

<span class="c"># 상태 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service
</code></pre></div></div>

<h3 id="서비스-관리-명령어">서비스 관리 명령어</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 서비스 중지</span>
<span class="nb">sudo </span>systemctl stop fastapi.service

<span class="c"># 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service

<span class="c"># 서비스 상태 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service

<span class="c"># 로그 확인 (최근 100줄)</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-n</span> 100

<span class="c"># 실시간 로그 모니터링</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-f</span>

<span class="c"># 서비스 자동 시작 비활성화</span>
<span class="nb">sudo </span>systemctl disable fastapi.service
</code></pre></div></div>

<blockquote>
  <p>💡 <strong>Tip</strong>: 코드를 수정한 후에는 <code class="language-plaintext highlighter-rouge">sudo systemctl restart fastapi.service</code>로 변경사항을 반영하세요.</p>
</blockquote>

<hr />

<h2 id="5-nginx-리버스-프록시-설정">5) Nginx 리버스 프록시 설정</h2>

<p>Nginx를 설치하고 FastAPI 애플리케이션 앞단에 리버스 프록시로 설정합니다.</p>

<h3 id="nginx-설치">Nginx 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Nginx 설치</span>
<span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> nginx

<span class="c"># Nginx 상태 확인</span>
<span class="nb">sudo </span>systemctl status nginx

<span class="c"># 기본 사이트 비활성화</span>
<span class="nb">sudo rm</span> /etc/nginx/sites-enabled/default
</code></pre></div></div>

<h3 id="사이트-구성-파일-생성">사이트 구성 파일 생성</h3>

<p><code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/reactbase</code> 파일을 생성합니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/nginx/sites-available/reactbase
</code></pre></div></div>

<p>아래 내용을 입력:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># HTTP/1.1 업그레이드 지원 (WebSocket용)</span>
<span class="k">map</span> <span class="nv">$http_upgrade</span> <span class="nv">$connection_upgrade</span> <span class="p">{</span>
    <span class="kn">default</span> <span class="s">upgrade</span><span class="p">;</span>
    <span class="kn">''</span> <span class="s">close</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">listen</span> <span class="s">[::]:80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">&lt;EC2_Public_IP_or_Domain&gt;</span><span class="p">;</span>

    <span class="c1"># 보안 헤더</span>
    <span class="kn">server_tokens</span> <span class="no">off</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">X-Content-Type-Options</span> <span class="s">nosniff</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">X-Frame-Options</span> <span class="s">DENY</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">X-XSS-Protection</span> <span class="s">"1</span><span class="p">;</span> <span class="kn">mode=block"</span><span class="p">;</span>

    <span class="c1"># 업로드 파일 크기 제한</span>
    <span class="kn">client_max_body_size</span> <span class="mi">10M</span><span class="p">;</span>

    <span class="c1"># 애플리케이션 서버로 프록시</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8000</span><span class="p">;</span>

        <span class="c1"># 프록시 헤더 설정</span>
        <span class="kn">proxy_http_version</span> <span class="mf">1.1</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Host</span>              <span class="nv">$host</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span>         <span class="nv">$remote_addr</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-For</span>   <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-Proto</span> <span class="nv">$scheme</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-Host</span>  <span class="nv">$host</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-Port</span>  <span class="nv">$server_port</span><span class="p">;</span>

        <span class="c1"># WebSocket 지원</span>
        <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span>           <span class="nv">$http_upgrade</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Connection</span>        <span class="nv">$connection_upgrade</span><span class="p">;</span>

        <span class="c1"># 타임아웃 설정</span>
        <span class="kn">proxy_connect_timeout</span> <span class="s">60s</span><span class="p">;</span>
        <span class="kn">proxy_send_timeout</span>    <span class="s">60s</span><span class="p">;</span>
        <span class="kn">proxy_read_timeout</span>    <span class="s">60s</span><span class="p">;</span>

        <span class="c1"># 버퍼링 설정</span>
        <span class="kn">proxy_buffering</span> <span class="no">off</span><span class="p">;</span>
        <span class="kn">proxy_redirect</span> <span class="no">off</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1"># 정적 파일 직접 서빙 (성능 향상)</span>
    <span class="kn">location</span> <span class="n">/images/</span> <span class="p">{</span>
        <span class="kn">alias</span> <span class="n">/home/ubuntu/reactbase/public/</span><span class="p">;</span>
        
        <span class="c1"># 보안 및 최적화</span>
        <span class="kn">autoindex</span> <span class="no">off</span><span class="p">;</span>
        <span class="kn">access_log</span> <span class="no">off</span><span class="p">;</span>
        
        <span class="c1"># 캐시 설정</span>
        <span class="kn">expires</span> <span class="s">1h</span><span class="p">;</span>
        <span class="kn">add_header</span> <span class="s">Cache-Control</span> <span class="s">"public,</span> <span class="s">immutable"</span><span class="p">;</span>
        
        <span class="c1"># MIME 타입 자동 설정</span>
        <span class="kn">include</span> <span class="n">/etc/nginx/mime.types</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1"># 헬스 체크 엔드포인트 (선택)</span>
    <span class="kn">location</span> <span class="n">/health</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8000/health</span><span class="p">;</span>
        <span class="kn">access_log</span> <span class="no">off</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1"># Favicon 에러 로그 무시 (선택)</span>
    <span class="kn">location</span> <span class="p">=</span> <span class="n">/favicon.ico</span> <span class="p">{</span>
        <span class="kn">access_log</span> <span class="no">off</span><span class="p">;</span>
        <span class="kn">log_not_found</span> <span class="no">off</span><span class="p">;</span>
        <span class="kn">return</span> <span class="mi">204</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>💡 <strong>Tip</strong>: <code class="language-plaintext highlighter-rouge">&lt;EC2_Public_IP_or_Domain&gt;</code> 부분은 실제 EC2 Public IP 또는 도메인으로 변경하세요.</p>

  <p>예: <code class="language-plaintext highlighter-rouge">server_name 3.35.123.456;</code> 또는 <code class="language-plaintext highlighter-rouge">server_name example.com;</code></p>
</blockquote>

<h3 id="설정-활성화-및-검증">설정 활성화 및 검증</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 심볼릭 링크 생성 (sites-enabled에 연결)</span>
<span class="nb">sudo ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/reactbase /etc/nginx/sites-enabled/

<span class="c"># Nginx 설정 문법 검증</span>
<span class="nb">sudo </span>nginx <span class="nt">-t</span>

<span class="c"># 출력 예시:</span>
<span class="c"># nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span>
<span class="c"># nginx: configuration file /etc/nginx/nginx.conf test is successful</span>
</code></pre></div></div>

<h3 id="nginx-재시작">Nginx 재시작</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Nginx 재시작</span>
<span class="nb">sudo </span>systemctl restart nginx

<span class="c"># 상태 확인</span>
<span class="nb">sudo </span>systemctl status nginx
</code></pre></div></div>

<h3 id="동작-확인-1">동작 확인</h3>

<p><strong>서버 내부에서 테스트:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># HTTP 헤더 확인</span>
curl <span class="nt">-I</span> http://localhost/

<span class="c"># 응답 본문 확인</span>
curl http://localhost/

<span class="c"># 정적 파일 테스트 (파일이 있는 경우)</span>
curl <span class="nt">-I</span> http://localhost/images/test.jpg
</code></pre></div></div>

<p><strong>외부 브라우저에서 테스트:</strong></p>

<p>브라우저에서 <code class="language-plaintext highlighter-rouge">http://&lt;EC2_Public_IP&gt;/</code> 접속 → <code class="language-plaintext highlighter-rouge">"welcome"</code> 확인</p>

<h3 id="nginx-관리-명령어">Nginx 관리 명령어</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설정 변경 후 문법 검증</span>
<span class="nb">sudo </span>nginx <span class="nt">-t</span>

<span class="c"># 무중단 설정 리로드 (권장)</span>
<span class="nb">sudo </span>systemctl reload nginx

<span class="c"># Nginx 재시작</span>
<span class="nb">sudo </span>systemctl restart nginx

<span class="c"># Nginx 중지</span>
<span class="nb">sudo </span>systemctl stop nginx

<span class="c"># Nginx 시작</span>
<span class="nb">sudo </span>systemctl start nginx

<span class="c"># 로그 확인</span>
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/nginx/access.log
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/nginx/error.log
</code></pre></div></div>

<blockquote>
  <p>⚠️ <strong>주의</strong>: 설정을 변경할 때는 항상 <code class="language-plaintext highlighter-rouge">sudo nginx -t</code>로 검증한 후 적용하세요.</p>
</blockquote>

<hr />

<h2 id="6-정적-파일-배치">6) 정적 파일 배치</h2>

<h3 id="정적-파일-디렉토리-구조">정적 파일 디렉토리 구조</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/ubuntu/reactbase/
├── server.py
├── venv/
└── public/              ← 정적 파일 저장 위치
    ├── logo.png
    ├── favicon.ico
    └── images/
        ├── banner.jpg
        └── profile.png
</code></pre></div></div>

<h3 id="파일-업로드-방법">파일 업로드 방법</h3>

<p><strong>방법 1: SCP로 파일 전송 (Linux/Mac)</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 단일 파일 업로드</span>
scp <span class="nt">-i</span> /경로/키.pem logo.png ubuntu@&lt;EC2_Public_IP&gt;:/home/ubuntu/reactbase/public/

<span class="c"># 폴더 전체 업로드</span>
scp <span class="nt">-i</span> /경로/키.pem <span class="nt">-r</span> images/ ubuntu@&lt;EC2_Public_IP&gt;:/home/ubuntu/reactbase/public/
</code></pre></div></div>

<p><strong>방법 2: Windows PowerShell</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SCP 사용</span><span class="w">
</span><span class="n">scp</span><span class="w"> </span><span class="nt">-i</span><span class="w"> </span><span class="nx">C:\</span><span class="err">경로</span><span class="nx">\</span><span class="err">키</span><span class="o">.</span><span class="nf">pem</span><span class="w"> </span><span class="nx">logo.png</span><span class="w"> </span><span class="nx">ubuntu</span><span class="err">@&lt;</span><span class="nx">EC2_Public_IP</span><span class="err">&gt;</span><span class="p">:</span><span class="nx">/home/ubuntu/reactbase/public/</span><span class="w">
</span></code></pre></div></div>

<p><strong>방법 3: 서버에서 직접 생성</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 테스트용 더미 파일 생성</span>
<span class="nb">cd</span> ~/reactbase/public
<span class="nb">echo</span> <span class="s2">"test"</span> <span class="o">&gt;</span> test.txt
</code></pre></div></div>

<h3 id="접근-경로-매핑">접근 경로 매핑</h3>

<table>
  <thead>
    <tr>
      <th>실제 파일 경로</th>
      <th>웹 브라우저 URL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/home/ubuntu/reactbase/public/logo.png</code></td>
      <td><code class="language-plaintext highlighter-rouge">http://&lt;EC2_IP&gt;/images/logo.png</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/home/ubuntu/reactbase/public/favicon.ico</code></td>
      <td><code class="language-plaintext highlighter-rouge">http://&lt;EC2_IP&gt;/images/favicon.ico</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/home/ubuntu/reactbase/public/images/banner.jpg</code></td>
      <td><code class="language-plaintext highlighter-rouge">http://&lt;EC2_IP&gt;/images/images/banner.jpg</code></td>
    </tr>
  </tbody>
</table>

<h3 id="장점">장점</h3>

<ul>
  <li><strong>성능 향상</strong>: Nginx가 직접 서빙하므로 애플리케이션 서버를 거치지 않음</li>
  <li><strong>효율성</strong>: Python 프로세스의 CPU/메모리 낭비 없음</li>
  <li><strong>캐싱</strong>: Nginx 레벨에서 브라우저 캐시 헤더 설정 가능</li>
  <li><strong>대용량 파일</strong>: 이미지, 비디오 등 대용량 파일도 효율적으로 서빙</li>
</ul>

<blockquote>
  <p>💡 <strong>Tip</strong>: HTML/CSS/JS 파일을 빌드한 프론트엔드 자산도 여기에 배치할 수 있습니다.</p>
</blockquote>

<hr />

<h2 id="7-vscode-sftp로-배포-자동화">7) VSCode SFTP로 배포 자동화</h2>

<p>VSCode SFTP 확장을 사용하면 파일 저장 시 자동으로 EC2 서버에 업로드할 수 있습니다.</p>

<h3 id="sftp-확장-설치">SFTP 확장 설치</h3>

<ol>
  <li>VSCode 확장 탭에서 <strong>“SFTP”</strong> 검색</li>
  <li><strong>“SFTP/FTP sync”</strong> (작성자: Natizyskunk) 설치</li>
</ol>

<h3 id="설정-파일-생성">설정 파일 생성</h3>

<p>로컬 프로젝트 루트에 <code class="language-plaintext highlighter-rouge">.vscode/sftp.json</code> 파일을 생성합니다:</p>

<p><strong>Linux/Mac 사용자:</strong></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"EC2 WebServer"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"host"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&lt;EC2_Public_IP&gt;"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"protocol"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sftp"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"port"</span><span class="p">:</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w">
  </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ubuntu"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"remotePath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/home/ubuntu/reactbase"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"uploadOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"useTempFile"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"openSsh"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"privateKeyPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/Users/yourname/pem/my_key.pem"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"ignore"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">".vscode"</span><span class="p">,</span><span class="w">
    </span><span class="s2">".git"</span><span class="p">,</span><span class="w">
    </span><span class="s2">".DS_Store"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"venv"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"__pycache__"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"*.pyc"</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Windows 사용자:</strong></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"EC2 WebServer"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"host"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&lt;EC2_Public_IP&gt;"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"protocol"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sftp"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"port"</span><span class="p">:</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w">
  </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ubuntu"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"remotePath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/home/ubuntu/reactbase"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"uploadOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"useTempFile"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"openSsh"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"privateKeyPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C:</span><span class="se">\\\\</span><span class="s2">Users</span><span class="se">\\\\</span><span class="s2">yourname</span><span class="se">\\\\</span><span class="s2">pem</span><span class="se">\\\\</span><span class="s2">my_key.pem"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"ignore"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">".vscode"</span><span class="p">,</span><span class="w">
    </span><span class="s2">".git"</span><span class="p">,</span><span class="w">
    </span><span class="s2">".DS_Store"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"venv"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"__pycache__"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"*.pyc"</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>⚠️ <strong>Windows 중요</strong>: 경로의 백슬래시(<code class="language-plaintext highlighter-rouge">\</code>)는 <strong>4개(<code class="language-plaintext highlighter-rouge">\\\\</code>)</strong> 로 이스케이프해야 합니다!</p>

  <p>예: <code class="language-plaintext highlighter-rouge">C:\Users\john\key.pem</code> → <code class="language-plaintext highlighter-rouge">"C:\\\\Users\\\\john\\\\key.pem"</code></p>
</blockquote>

<h3 id="설정-항목-설명-1">설정 항목 설명</h3>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">name</code></td>
      <td>연결 이름 (식별용)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">host</code></td>
      <td>EC2 Public IP</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remotePath</code></td>
      <td>서버의 프로젝트 디렉토리 경로</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">uploadOnSave</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code>로 설정 시 파일 저장 시 자동 업로드</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">privateKeyPath</code></td>
      <td>PEM 키 파일의 절대 경로</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ignore</code></td>
      <td>업로드 제외할 파일/폴더 패턴</td>
    </tr>
  </tbody>
</table>

<h3 id="사용-방법">사용 방법</h3>

<ol>
  <li><strong>파일 수정 후 저장</strong> (<code class="language-plaintext highlighter-rouge">Ctrl+S</code> 또는 <code class="language-plaintext highlighter-rouge">Cmd+S</code>)</li>
  <li>자동으로 EC2 서버에 업로드됨</li>
  <li>서비스 재시작으로 변경사항 반영:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl restart fastapi.service
</code></pre></div></div>

<h3 id="sftp-수동-명령어">SFTP 수동 명령어</h3>

<p>VSCode 명령 팔레트 (<code class="language-plaintext highlighter-rouge">Ctrl+Shift+P</code> 또는 <code class="language-plaintext highlighter-rouge">Cmd+Shift+P</code>)에서:</p>

<ul>
  <li><strong>SFTP: Upload File</strong> - 현재 파일 업로드</li>
  <li><strong>SFTP: Upload Folder</strong> - 폴더 전체 업로드</li>
  <li><strong>SFTP: Download File</strong> - 서버에서 파일 다운로드</li>
  <li><strong>SFTP: Sync Local → Remote</strong> - 로컬을 서버로 동기화</li>
  <li><strong>SFTP: Sync Remote → Local</strong> - 서버를 로컬로 동기화</li>
</ul>

<h3 id="트러블슈팅">트러블슈팅</h3>

<p><strong>문제: “All configured authentication methods failed”</strong></p>

<ul>
  <li>PEM 키 경로가 올바른지 확인</li>
  <li>Windows에서 백슬래시 이스케이프 확인 (<code class="language-plaintext highlighter-rouge">\\\\</code>)</li>
  <li>PEM 파일 권한 확인 (Linux/Mac: <code class="language-plaintext highlighter-rouge">chmod 400 키.pem</code>)</li>
</ul>

<p><strong>문제: “Permission denied”</strong></p>

<ul>
  <li>EC2 보안 그룹에서 22번 포트(SSH) 허용 확인</li>
  <li><code class="language-plaintext highlighter-rouge">username</code>이 <code class="language-plaintext highlighter-rouge">ubuntu</code>인지 확인 (Ubuntu AMI의 기본 사용자)</li>
</ul>

<p><strong>배포 후 변경사항이 반영되지 않음:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># FastAPI 서비스 재시작 필요</span>
<span class="nb">sudo </span>systemctl restart fastapi.service

<span class="c"># 로그 확인</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-n</span> 50
</code></pre></div></div>

<blockquote>
  <p>💡 <strong>Tip</strong>: <code class="language-plaintext highlighter-rouge">uploadOnSave: true</code>로 설정하면 개발 속도가 크게 향상됩니다!</p>
</blockquote>

<hr />

<h2 id="8-운영-체크리스트--트러블슈팅">8) 운영 체크리스트 &amp; 트러블슈팅</h2>

<h3 id="a-보안-그룹네트워크">A. 보안 그룹/네트워크</h3>

<p><strong>필수 포트 설정</strong></p>

<table>
  <thead>
    <tr>
      <th>포트</th>
      <th>상태</th>
      <th>용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>22</td>
      <td>열림</td>
      <td>SSH 접속</td>
    </tr>
    <tr>
      <td>80</td>
      <td>열림</td>
      <td>HTTP 웹 서비스</td>
    </tr>
    <tr>
      <td>8000</td>
      <td><strong>닫힘</strong></td>
      <td>외부 노출 불필요 (Nginx를 통해서만 접근)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>⚠️ <strong>주의</strong>: 8000 포트는 보안상 외부에 열지 마세요. 테스트가 필요한 경우에만 임시로 개방 후 즉시 닫으세요.</p>
</blockquote>

<p><strong>보안 그룹 확인 방법:</strong></p>
<ol>
  <li>AWS 콘솔 → EC2 → 인스턴스 선택</li>
  <li><strong>보안</strong> 탭 → <strong>보안 그룹</strong> 클릭</li>
  <li><strong>인바운드 규칙</strong> 확인</li>
</ol>

<h3 id="b-isp통신사-차단-이슈">B. ISP/통신사 차단 이슈</h3>

<p><strong>증상:</strong></p>
<ul>
  <li>AWS 보안 그룹은 정상적으로 설정되어 있음</li>
  <li>서버 내부에서는 정상 접속 (<code class="language-plaintext highlighter-rouge">curl localhost</code>)</li>
  <li>외부에서 접속이 안 됨</li>
</ul>

<p><strong>원인 및 해결:</strong></p>

<p>가정용 인터넷(KT, SKT, LG U+ 등)에서는 특정 포트가 <strong>ISP 레벨에서 차단</strong>될 수 있습니다.</p>

<p><strong>해결 방법:</strong></p>
<ol>
  <li><strong>휴대폰 핫스팟</strong>으로 전환하여 테스트</li>
  <li>접속이 되면 → ISP 차단 문제</li>
  <li>해결:
    <ul>
      <li>ISP에 문의하여 포트 개방 요청</li>
      <li>또는 443 포트(HTTPS) 사용</li>
      <li>VPN 사용</li>
    </ul>
  </li>
</ol>

<h3 id="c-ssh-접속-문제">C. SSH 접속 문제</h3>

<p><strong>문제: <code class="language-plaintext highlighter-rouge">Permission denied (publickey)</code></strong></p>

<p><strong>원인 체크리스트:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. PEM 키 파일이 올바른지 확인</span>
<span class="c"># EC2 인스턴스 생성 시 선택한 키 페어와 일치해야 함</span>

<span class="c"># 2. 파일 권한 확인 (Linux/Mac)</span>
<span class="nb">chmod </span>400 키.pem

<span class="c"># 3. 올바른 사용자명 사용</span>
<span class="c"># Ubuntu AMI: ubuntu</span>
<span class="c"># Amazon Linux: ec2-user</span>
ssh <span class="nt">-i</span> 키.pem ubuntu@&lt;IP&gt;

<span class="c"># 4. 보안 그룹에서 22번 포트 확인</span>
<span class="c"># 소스: 0.0.0.0/0 (또는 내 IP만)</span>
</code></pre></div></div>

<p><strong>Windows 특수 문제:</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># PEM 파일 권한 설정 (PowerShell 관리자 권한)</span><span class="w">
</span><span class="n">icacls</span><span class="w"> </span><span class="s2">"C:\경로\키.pem"</span><span class="w"> </span><span class="nx">/inheritance:r</span><span class="w">
</span><span class="n">icacls</span><span class="w"> </span><span class="s2">"C:\경로\키.pem"</span><span class="w"> </span><span class="nx">/grant:r</span><span class="w"> </span><span class="s2">"%username%:R"</span><span class="w">
</span></code></pre></div></div>

<h3 id="d-nginx-문제-해결">D. Nginx 문제 해결</h3>

<p><strong>문제: 502 Bad Gateway</strong></p>

<p><strong>원인:</strong></p>
<ul>
  <li>FastAPI 서비스가 실행 중이지 않음</li>
  <li>포트 불일치 (Nginx는 8000으로 프록시하는데 Uvicorn은 다른 포트에서 실행)</li>
</ul>

<p><strong>해결:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># FastAPI 서비스 상태 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service

<span class="c"># 서비스가 실패했다면 로그 확인</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-n</span> 100

<span class="c"># 포트 확인 (8000 포트에서 리스닝 중인지)</span>
<span class="nb">sudo </span>netstat <span class="nt">-tulpn</span> | <span class="nb">grep</span> :8000
<span class="c"># 또는</span>
<span class="nb">sudo </span>ss <span class="nt">-tulpn</span> | <span class="nb">grep</span> :8000

<span class="c"># 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service
</code></pre></div></div>

<p><strong>문제: Nginx 설정 오류</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설정 파일 문법 검증</span>
<span class="nb">sudo </span>nginx <span class="nt">-t</span>

<span class="c"># 자주 발생하는 오류:</span>
<span class="c"># 1. 세미콜론(;) 누락</span>
<span class="c"># 2. 중괄호 불일치</span>
<span class="c"># 3. 파일 경로 오타</span>

<span class="c"># 로그 확인</span>
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/nginx/error.log
</code></pre></div></div>

<p><strong>문제: 정적 파일(이미지) 404</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디렉토리 권한 확인</span>
<span class="nb">ls</span> <span class="nt">-ld</span> /home/ubuntu/reactbase/public/
<span class="nb">ls</span> <span class="nt">-l</span> /home/ubuntu/reactbase/public/

<span class="c"># Nginx 사용자가 접근 가능해야 함</span>
<span class="c"># 권한 문제라면:</span>
<span class="nb">chmod </span>755 /home/ubuntu/reactbase/public/
<span class="nb">chmod </span>644 /home/ubuntu/reactbase/public/<span class="k">*</span>

<span class="c"># Nginx 설정에서 alias 경로 확인</span>
<span class="c"># 끝에 슬래시(/) 필수!</span>
<span class="c"># location /images/ {</span>
<span class="c">#     alias /home/ubuntu/reactbase/public/;</span>
<span class="c"># }</span>
</code></pre></div></div>

<h3 id="e-fastapiuvicorn-문제-해결">E. FastAPI/Uvicorn 문제 해결</h3>

<p><strong>서비스 관리:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상태 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service

<span class="c"># 로그 확인 (최근 200줄)</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-n</span> 200

<span class="c"># 실시간 로그 모니터링</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-f</span>

<span class="c"># 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service

<span class="c"># 서비스 파일 수정 후 리로드</span>
<span class="nb">sudo </span>systemctl daemon-reload
</code></pre></div></div>

<p><strong>성능 최적화 - Worker 프로세스:</strong></p>

<p>CPU 코어 수에 따라 worker 수 조정:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># CPU 코어 수 확인</span>
<span class="nb">nproc</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">/etc/systemd/system/fastapi.service</code> 수정:</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 코어가 2개라면 workers=2 또는 3
</span><span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app </span><span class="se">\
</span><span class="w">    </span><span class="s">--host 0.0.0.0 </span><span class="se">\
</span><span class="w">    </span><span class="s">--port 8000 </span><span class="se">\
</span><span class="w">    </span><span class="s">--workers 2 </span><span class="se">\
</span><span class="w">    </span><span class="s">--proxy-headers </span><span class="se">\
</span><span class="w">    </span><span class="s">--forwarded-allow-ips="*"</span>
</code></pre></div></div>

<blockquote>
  <p>💡 <strong>권장</strong>: <code class="language-plaintext highlighter-rouge">workers = (2 × CPU 코어 수) + 1</code></p>
</blockquote>

<p><strong>Python 모듈 오류:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 가상환경 활성화 후 패키지 재설치</span>
<span class="nb">cd</span> ~/reactbase
<span class="nb">source </span>venv/bin/activate
pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip
pip <span class="nb">install </span>fastapi uvicorn[standard]
</code></pre></div></div>

<h3 id="f-재부팅-후-자동-시작-확인">F. 재부팅 후 자동 시작 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 자동 시작 활성화 상태 확인</span>
<span class="nb">sudo </span>systemctl is-enabled fastapi.service
<span class="c"># 출력: enabled (활성화됨)</span>
<span class="c"># 출력: disabled (비활성화됨)</span>

<span class="c"># 비활성화되어 있다면:</span>
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>fastapi.service

<span class="c"># 재부팅 테스트</span>
<span class="nb">sudo </span>reboot

<span class="c"># 재접속 후 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service
<span class="nb">sudo </span>systemctl status nginx
</code></pre></div></div>

<h3 id="g-모니터링--로그">G. 모니터링 &amp; 로그</h3>

<p><strong>시스템 리소스 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># CPU, 메모리 사용량 실시간 모니터링</span>
htop
<span class="c"># 또는</span>
top

<span class="c"># 디스크 사용량</span>
<span class="nb">df</span> <span class="nt">-h</span>

<span class="c"># 메모리 사용량</span>
free <span class="nt">-h</span>
</code></pre></div></div>

<p><strong>로그 위치:</strong></p>

<table>
  <thead>
    <tr>
      <th>서비스</th>
      <th>로그 위치</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FastAPI</td>
      <td><code class="language-plaintext highlighter-rouge">sudo journalctl -u fastapi.service</code></td>
    </tr>
    <tr>
      <td>Nginx 액세스</td>
      <td><code class="language-plaintext highlighter-rouge">/var/log/nginx/access.log</code></td>
    </tr>
    <tr>
      <td>Nginx 에러</td>
      <td><code class="language-plaintext highlighter-rouge">/var/log/nginx/error.log</code></td>
    </tr>
    <tr>
      <td>시스템</td>
      <td><code class="language-plaintext highlighter-rouge">/var/log/syslog</code></td>
    </tr>
  </tbody>
</table>

<p><strong>로그 모니터링 명령어:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># FastAPI 실시간 로그</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-f</span>

<span class="c"># Nginx 액세스 로그 실시간</span>
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/nginx/access.log

<span class="c"># Nginx 에러 로그 실시간</span>
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/nginx/error.log

<span class="c"># 여러 로그 동시 모니터링</span>
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/nginx/access.log /var/log/nginx/error.log
</code></pre></div></div>

<hr />

<h2 id="9-https선택--곧바로-운영-반영-시-권장">9) HTTPS(선택) — 곧바로 운영 반영 시 권장</h2>

<p>운영 환경에서는 보안을 위해 <strong>HTTPS</strong>를 사용해야 합니다.</p>

<p>도메인이 있다면 <strong>Let’s Encrypt(certbot)</strong>으로 무료 SSL/TLS 인증서를 발급받을 수 있습니다.</p>

<h3 id="사전-준비">사전 준비</h3>

<ol>
  <li><strong>도메인 필요</strong>: 도메인을 구매하고 EC2 Public IP를 가리키도록 DNS A 레코드 설정</li>
  <li><strong>방화벽</strong>: 보안 그룹에서 <strong>443 포트(HTTPS)</strong> 추가 개방</li>
</ol>

<table>
  <thead>
    <tr>
      <th>포트</th>
      <th>프로토콜</th>
      <th>소스</th>
      <th>용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>443</td>
      <td>TCP</td>
      <td>0.0.0.0/0</td>
      <td>HTTPS</td>
    </tr>
  </tbody>
</table>

<h3 id="certbot-설치-및-인증서-발급">Certbot 설치 및 인증서 발급</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Certbot 및 Nginx 플러그인 설치</span>
<span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> certbot python3-certbot-nginx

<span class="c"># SSL 인증서 자동 발급 및 Nginx 설정</span>
<span class="nb">sudo </span>certbot <span class="nt">--nginx</span> <span class="nt">-d</span> your.domain.com

<span class="c"># 여러 도메인을 동시에 지원하는 경우</span>
<span class="nb">sudo </span>certbot <span class="nt">--nginx</span> <span class="nt">-d</span> your.domain.com <span class="nt">-d</span> www.your.domain.com
</code></pre></div></div>

<p><strong>대화형 프롬프트:</strong></p>
<ol>
  <li>이메일 입력 (인증서 만료 알림용)</li>
  <li>이용약관 동의</li>
  <li>HTTP → HTTPS 리다이렉트 설정 여부 (권장: Yes)</li>
</ol>

<h3 id="설정-후-변경사항">설정 후 변경사항</h3>

<p>Certbot이 자동으로 Nginx 설정을 수정합니다:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">your.domain.com</span><span class="p">;</span>
    <span class="c1"># HTTP → HTTPS 리다이렉트 자동 추가</span>
    <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$server_name$request_uri</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">your.domain.com</span><span class="p">;</span>

    <span class="c1"># SSL 인증서 경로 (자동 설정됨)</span>
    <span class="kn">ssl_certificate</span> <span class="n">/etc/letsencrypt/live/your.domain.com/fullchain.pem</span><span class="p">;</span>
    <span class="kn">ssl_certificate_key</span> <span class="n">/etc/letsencrypt/live/your.domain.com/privkey.pem</span><span class="p">;</span>
    <span class="kn">include</span> <span class="n">/etc/letsencrypt/options-ssl-nginx.conf</span><span class="p">;</span>
    <span class="kn">ssl_dhparam</span> <span class="n">/etc/letsencrypt/ssl-dhparams.pem</span><span class="p">;</span>

    <span class="c1"># 기존 location 블록들...</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8000</span><span class="p">;</span>
        <span class="c1"># ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="인증서-자동-갱신">인증서 자동 갱신</h3>

<p>Let’s Encrypt 인증서는 <strong>90일</strong> 유효기간을 가집니다.</p>

<p>Certbot은 자동 갱신 타이머를 설정합니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 자동 갱신 타이머 상태 확인</span>
<span class="nb">sudo </span>systemctl status certbot.timer

<span class="c"># 갱신 테스트 (실제로 갱신하지 않고 테스트만)</span>
<span class="nb">sudo </span>certbot renew <span class="nt">--dry-run</span>

<span class="c"># 수동 갱신 (필요한 경우)</span>
<span class="nb">sudo </span>certbot renew
</code></pre></div></div>

<h3 id="https-동작-확인">HTTPS 동작 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로컬에서 테스트</span>
curl <span class="nt">-I</span> https://your.domain.com

<span class="c"># SSL 인증서 정보 확인</span>
openssl s_client <span class="nt">-connect</span> your.domain.com:443 <span class="nt">-servername</span> your.domain.com
</code></pre></div></div>

<p><strong>브라우저에서 확인:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">https://your.domain.com</code> 접속</li>
  <li>주소창에 자물쇠 아이콘 확인</li>
  <li>인증서 정보 확인</li>
</ul>

<h3 id="추가-보안-설정-선택">추가 보안 설정 (선택)</h3>

<p>HTTPS 설정 후 추가 보안 헤더를 Nginx에 추가할 수 있습니다:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">your.domain.com</span><span class="p">;</span>

    <span class="c1"># HSTS (HTTP Strict Transport Security)</span>
    <span class="kn">add_header</span> <span class="s">Strict-Transport-Security</span> <span class="s">"max-age=31536000</span><span class="p">;</span> <span class="kn">includeSubDomains"</span> <span class="s">always</span><span class="p">;</span>

    <span class="c1"># 기존 보안 헤더들...</span>
    <span class="kn">add_header</span> <span class="s">X-Content-Type-Options</span> <span class="s">nosniff</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">X-Frame-Options</span> <span class="s">DENY</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">X-XSS-Protection</span> <span class="s">"1</span><span class="p">;</span> <span class="kn">mode=block"</span><span class="p">;</span>

    <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>설정 후 Nginx 리로드:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nginx <span class="nt">-t</span>
<span class="nb">sudo </span>systemctl reload nginx
</code></pre></div></div>

<blockquote>
  <p>💡 <strong>Tip</strong>: 도메인이 없어도 Self-Signed 인증서로 HTTPS를 사용할 수 있지만, 브라우저에서 경고가 표시됩니다.</p>
</blockquote>

<hr />

<h2 id="10-최종-점검-시나리오">10) 최종 점검 시나리오</h2>

<p>전체 설정이 완료되었다면 아래 체크리스트로 동작을 확인하세요.</p>

<h3 id="체크리스트">체크리스트</h3>

<p><strong>1. 서비스 상태 확인</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># FastAPI 서비스 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service
<span class="c"># 출력: active (running) 이어야 함</span>

<span class="c"># Nginx 서비스 확인</span>
<span class="nb">sudo </span>systemctl status nginx
<span class="c"># 출력: active (running) 이어야 함</span>

<span class="c"># 포트 리스닝 확인</span>
<span class="nb">sudo </span>netstat <span class="nt">-tulpn</span> | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s1">':80|:8000'</span>
<span class="c"># 80 포트: nginx</span>
<span class="c"># 8000 포트: uvicorn</span>
</code></pre></div></div>

<p><strong>2. 로컬 테스트 (EC2 서버 내부)</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Uvicorn 직접 접근 테스트</span>
curl <span class="nt">-s</span> http://127.0.0.1:8000/
<span class="c"># 출력: welcome</span>

<span class="c"># Nginx를 통한 접근 테스트</span>
curl <span class="nt">-I</span> http://localhost/
<span class="c"># 출력: HTTP/1.1 200 OK</span>

curl http://localhost/
<span class="c"># 출력: welcome</span>

<span class="c"># 헬스 체크 엔드포인트</span>
curl http://localhost/health
<span class="c"># 출력: {"status":"healthy","service":"fastapi"}</span>

<span class="c"># 추가 엔드포인트 테스트</span>
curl http://localhost/hello  <span class="c"># 출력: hello</span>
curl http://localhost/world  <span class="c"># 출력: world</span>
</code></pre></div></div>

<p><strong>3. 외부 접근 테스트 (브라우저)</strong></p>

<p>로컬 PC 브라우저에서 다음 URL 접속:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">http://&lt;EC2_Public_IP&gt;/</code> → <code class="language-plaintext highlighter-rouge">"welcome"</code> 출력 확인</li>
  <li><code class="language-plaintext highlighter-rouge">http://&lt;EC2_Public_IP&gt;/hello</code> → <code class="language-plaintext highlighter-rouge">"hello"</code> 출력 확인</li>
  <li><code class="language-plaintext highlighter-rouge">http://&lt;EC2_Public_IP&gt;/health</code> → JSON 응답 확인</li>
  <li><code class="language-plaintext highlighter-rouge">http://&lt;EC2_Public_IP&gt;/docs</code> → FastAPI 자동 생성 API 문서 확인</li>
</ul>

<p><strong>4. 정적 파일 테스트</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 테스트 파일 생성</span>
<span class="nb">echo</span> <span class="s2">"Static file test"</span> <span class="o">&gt;</span> ~/reactbase/public/test.txt

<span class="c"># 서버 내부에서 테스트</span>
curl http://localhost/images/test.txt

<span class="c"># 외부 브라우저에서 테스트</span>
<span class="c"># http://&lt;EC2_Public_IP&gt;/images/test.txt</span>
</code></pre></div></div>

<p><strong>5. 개발 워크플로우 테스트</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 로컬에서 server.py 수정</span>
<span class="c"># 예: 새 엔드포인트 추가</span>

<span class="c"># 2. VSCode에서 저장 (자동 업로드)</span>

<span class="c"># 3. 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service

<span class="c"># 4. 변경사항 확인</span>
curl http://localhost/새로운엔드포인트
</code></pre></div></div>

<p><strong>6. 재부팅 테스트</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 서버 재부팅</span>
<span class="nb">sudo </span>reboot

<span class="c"># 재접속 후 (약 1-2분 후)</span>
ssh <span class="nt">-i</span> 키.pem ubuntu@&lt;EC2_Public_IP&gt;

<span class="c"># 자동 시작 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service
<span class="nb">sudo </span>systemctl status nginx

<span class="c"># 외부 접근 확인</span>
curl http://localhost/
</code></pre></div></div>

<h3 id="성공-기준">성공 기준</h3>

<p>✅ <strong>모든 서비스가 <code class="language-plaintext highlighter-rouge">active (running)</code> 상태</strong></p>

<p>✅ <strong>로컬에서 모든 엔드포인트 정상 응답</strong></p>

<p>✅ <strong>외부 브라우저에서 접근 가능</strong></p>

<p>✅ <strong>정적 파일 서빙 정상 동작</strong></p>

<p>✅ <strong>재부팅 후 자동 시작 확인</strong></p>

<h3 id="문제-발생-시">문제 발생 시</h3>

<p>문제가 발생하면 <a href="#8-운영-체크리스트--트러블슈팅">8) 운영 체크리스트 &amp; 트러블슈팅</a> 섹션을 참고하세요.</p>

<hr />

<h2 id="-결론">📌 결론</h2>

<h3 id="구축한-아키텍처-요약">구축한 아키텍처 요약</h3>

<p>이 가이드를 통해 다음과 같은 <strong>프로덕션 수준의 웹 서버 환경</strong>을 구축했습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────────────────────┐
│             Internet                     │
└──────────────┬──────────────────────────┘
               │ Port 80 (HTTP)
               │
┌──────────────▼──────────────────────────┐
│        AWS EC2 (Ubuntu)                  │
│  ┌────────────────────────────────────┐  │
│  │  Nginx (Reverse Proxy)             │  │
│  │  - Security Headers                │  │
│  │  - Static File Serving             │  │
│  │  - Load Balancing (확장 가능)      │  │
│  └──────────┬─────────────────────────┘  │
│             │ 127.0.0.1:8000              │
│  ┌──────────▼─────────────────────────┐  │
│  │  FastAPI (Uvicorn)                 │  │
│  │  - systemd Auto-start              │  │
│  │  - Multi-worker Support            │  │
│  │  - Application Logic               │  │
│  └────────────────────────────────────┘  │
└─────────────────────────────────────────┘
</code></pre></div></div>

<h3 id="핵심-성과">핵심 성과</h3>

<p><strong>✅ 보안</strong></p>
<ul>
  <li>애플리케이션 서버(8000 포트)는 외부에 노출되지 않음</li>
  <li>Nginx를 통한 요청 필터링 및 보안 헤더 설정</li>
  <li>HTTPS 적용 가능 (Let’s Encrypt)</li>
</ul>

<p><strong>✅ 안정성</strong></p>
<ul>
  <li>systemd로 재부팅 시 자동 시작</li>
  <li>프로세스 실패 시 자동 재시작</li>
  <li>헬스 체크 엔드포인트로 모니터링 가능</li>
</ul>

<p><strong>✅ 성능</strong></p>
<ul>
  <li>Nginx가 정적 파일을 직접 서빙 (애플리케이션 서버 부하 감소)</li>
  <li>Multi-worker 프로세스로 동시 처리 능력 향상</li>
  <li>브라우저 캐싱 설정으로 네트워크 트래픽 감소</li>
</ul>

<p><strong>✅ 개발 생산성</strong></p>
<ul>
  <li>VSCode SFTP로 파일 저장 시 자동 배포</li>
  <li>FastAPI 자동 생성 API 문서 (<code class="language-plaintext highlighter-rouge">/docs</code>)</li>
  <li>journalctl로 실시간 로그 모니터링</li>
</ul>

<h3 id="실무-팁-요약">실무 팁 요약</h3>

<p><strong>보안 그룹 설정</strong></p>
<ul>
  <li>22 (SSH), 80 (HTTP), 443 (HTTPS)만 개방</li>
  <li>8000 포트는 외부에 열지 말 것</li>
</ul>

<p><strong>ISP 차단 문제</strong></p>
<ul>
  <li>접속이 안 되면 휴대폰 핫스팟으로 테스트</li>
  <li>ISP 레벨 차단일 가능성 확인</li>
</ul>

<p><strong>Windows 사용자</strong></p>
<ul>
  <li>SFTP 경로 백슬래시 4개 이스케이프 (<code class="language-plaintext highlighter-rouge">\\\\</code>)</li>
  <li>PEM 파일 권한 설정 (<code class="language-plaintext highlighter-rouge">icacls</code> 명령어)</li>
</ul>

<p><strong>로그 모니터링</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># FastAPI 로그</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-f</span>

<span class="c"># Nginx 로그</span>
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/nginx/error.log
</code></pre></div></div>

<h3 id="다음-단계-제안">다음 단계 제안</h3>

<p>현재 구축한 기본 환경을 바탕으로 다음 기능들을 추가할 수 있습니다:</p>

<p><strong>1. HTTPS 적용</strong></p>
<ul>
  <li>Let’s Encrypt로 무료 SSL 인증서</li>
  <li>HTTP → HTTPS 자동 리다이렉트</li>
</ul>

<p><strong>2. 데이터베이스 연동</strong></p>
<ul>
  <li>PostgreSQL, MySQL, MongoDB 등</li>
  <li>RDS(관리형 데이터베이스) 사용 권장</li>
</ul>

<p><strong>3. 모니터링 &amp; 알림</strong></p>
<ul>
  <li>CloudWatch 로그 전송</li>
  <li>Prometheus + Grafana</li>
  <li>에러 발생 시 이메일/Slack 알림</li>
</ul>

<p><strong>4. CI/CD 파이프라인</strong></p>
<ul>
  <li>GitHub Actions로 자동 배포</li>
  <li>테스트 자동화</li>
</ul>

<p><strong>5. 컨테이너화</strong></p>
<ul>
  <li>Docker로 애플리케이션 패키징</li>
  <li>ECS/EKS로 오케스트레이션</li>
</ul>

<p><strong>6. 부하 분산</strong></p>
<ul>
  <li>Application Load Balancer (ALB)</li>
  <li>Auto Scaling Group</li>
</ul>

<p><strong>7. 백업 &amp; 재해 복구</strong></p>
<ul>
  <li>데이터베이스 정기 백업</li>
  <li>AMI 스냅샷</li>
  <li>다중 AZ 배포</li>
</ul>

<h3 id="마무리">마무리</h3>

<p>이제 <strong>EC2에서 FastAPI + Nginx 리버스 프록시 구조</strong>로 안전하고 효율적인 웹 서비스를 운영할 수 있는 기반이 마련되었습니다.</p>

<p><strong>systemd</strong> 자동 기동, <strong>SFTP</strong> 배포 자동화, <strong>트러블슈팅</strong> 가이드까지 실무에서 바로 활용할 수 있는 내용을 담았습니다.</p>

<p>운영하면서 발생하는 이슈들은 이 가이드의 트러블슈팅 섹션을 참고하시고, 추가 질문이 있다면 AWS 공식 문서나 커뮤니티를 활용하세요!</p>

<p><strong>행복한 배포 되세요!</strong> 🚀</p>

<hr />

<h2 id="-참고-자료">📚 참고 자료</h2>

<ul>
  <li><a href="https://fastapi.tiangolo.com/">FastAPI 공식 문서</a></li>
  <li><a href="https://www.uvicorn.org/">Uvicorn 공식 문서</a></li>
  <li><a href="https://nginx.org/en/docs/">Nginx 공식 문서</a></li>
  <li><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">systemd 서비스 관리</a></li>
  <li><a href="https://certbot.eff.org/">Let’s Encrypt (Certbot)</a></li>
  <li><a href="https://docs.aws.amazon.com/ec2/">AWS EC2 사용 설명서</a></li>
</ul>

<hr />

<p><strong>작성일</strong>: 2025년 10월 12일<br />
<strong>카테고리</strong>: DevOps, AWS<br />
<strong>태그</strong>: EC2, Nginx, FastAPI, Uvicorn, Ubuntu, systemd, ReverseProxy, SFTP</p>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="Learning" /><category term="EC2" /><category term="Nginx" /><category term="FastAPI" /><category term="Uvicorn" /><category term="Ubuntu" /><category term="systemd" /><category term="ReverseProxy" /><category term="SFTP" /><category term="DevOps" /><category term="AWS" /><summary type="html"><![CDATA[EC2 서버에 Nginx와 Application Server 연결 설정, 운영 팁까지]]></summary></entry><entry><title type="html">AWS EC2 FastAPI 프로덕션 배포 완전 가이드</title><link href="http://localhost:4000/my-blog/learning/2025/10/11/study-aws.html" rel="alternate" type="text/html" title="AWS EC2 FastAPI 프로덕션 배포 완전 가이드" /><published>2025-10-11T19:30:00+09:00</published><updated>2025-10-11T19:30:00+09:00</updated><id>http://localhost:4000/my-blog/learning/2025/10/11/study-aws</id><content type="html" xml:base="http://localhost:4000/my-blog/learning/2025/10/11/study-aws.html"><![CDATA[<h1 id="aws-ec2-fastapi-프로덕션-배포-완전-가이드">AWS EC2 FastAPI 프로덕션 배포 완전 가이드</h1>

<h2 id="개요">개요</h2>

<p>본 문서는 AWS EC2 Ubuntu 환경에서 FastAPI 애플리케이션을 프로덕션 수준으로 배포하기 위한 종합적인 기술 레퍼런스입니다.</p>

<p>기본적인 서버 구축부터 시작하여, systemd를 통한 프로세스 관리, Nginx 리버스 프록시 구성, HTTPS 인증서 설정, 보안 강화, 성능 최적화, 모니터링 및 로깅까지 프로덕션 환경에 필요한 모든 측면을 다룹니다.</p>

<p><strong>주요 다루는 내용:</strong></p>

<ul>
  <li>EC2 인스턴스 설정 및 네트워크 보안 구성</li>
  <li>Python 가상환경 및 FastAPI 애플리케이션 구성</li>
  <li>systemd를 통한 서비스 자동화 및 프로세스 관리</li>
  <li>Nginx 리버스 프록시 설정 및 최적화</li>
  <li>Let’s Encrypt를 통한 무료 SSL/TLS 인증서 발급</li>
  <li>UFW 방화벽 및 Fail2ban을 통한 보안 강화</li>
  <li>로그 관리, 디버깅 및 트러블슈팅</li>
  <li>성능 최적화 및 모니터링 전략</li>
</ul>

<hr />

<h2 id="목차">목차</h2>

<ol>
  <li><a href="#사전-요구사항">사전 요구사항</a></li>
  <li><a href="#환경-준비">환경 준비</a></li>
  <li><a href="#python-및-필수-패키지-설치">Python 및 필수 패키지 설치</a></li>
  <li><a href="#프로젝트-디렉터리-구성">프로젝트 디렉터리 구성</a></li>
  <li><a href="#가상환경-구성-및-fastapi-설치">가상환경 구성 및 FastAPI 설치</a></li>
  <li><a href="#fastapi-애플리케이션-코드">FastAPI 애플리케이션 코드</a></li>
  <li><a href="#서버-실행-테스트">서버 실행 테스트</a></li>
  <li><a href="#aws-보안-그룹-설정">AWS 보안 그룹 설정</a></li>
  <li><a href="#systemd를-통한-자동-실행-설정">systemd를 통한 자동 실행 설정</a></li>
  <li><a href="#환경-변수-관리">환경 변수 관리</a></li>
  <li><a href="#로그-관리-및-디버깅">로그 관리 및 디버깅</a></li>
  <li><a href="#nginx-리버스-프록시-설정">Nginx 리버스 프록시 설정</a></li>
  <li><a href="#https-설정-lets-encrypt">HTTPS 설정 (Let’s Encrypt)</a></li>
  <li><a href="#보안-강화">보안 강화</a></li>
  <li><a href="#성능-최적화">성능 최적화</a></li>
  <li><a href="#모니터링-및-유지보수">모니터링 및 유지보수</a></li>
  <li><a href="#vscode-sftp-설정">VSCode SFTP 설정</a></li>
  <li><a href="#트러블슈팅">트러블슈팅</a></li>
  <li><a href="#참고-자료">참고 자료</a></li>
</ol>

<hr />

<h2 id="사전-요구사항">사전 요구사항</h2>

<h3 id="시스템-요구사항">시스템 요구사항</h3>

<p><strong>AWS 리소스:</strong></p>
<ul>
  <li>EC2 인스턴스 (최소 t2.micro, 권장 t2.small 이상)</li>
  <li>탄력적 IP 주소 (Elastic IP) - 프로덕션 환경 권장</li>
  <li>보안 그룹 설정 권한</li>
</ul>

<p><strong>로컬 환경:</strong></p>
<ul>
  <li>SSH 클라이언트 (Windows: PowerShell/PuTTY, macOS/Linux: 터미널)</li>
  <li>PEM 키 파일</li>
  <li>VSCode (선택사항, 배포 자동화용)</li>
</ul>

<p><strong>소프트웨어 버전:</strong></p>
<ul>
  <li>Ubuntu 24.04.2 LTS (또는 22.04 LTS)</li>
  <li>Python 3.10 이상 (권장: 3.11+)</li>
  <li>FastAPI 0.100.0 이상</li>
  <li>Uvicorn 0.23.0 이상</li>
  <li>Nginx 1.18.0 이상 (리버스 프록시 사용 시)</li>
</ul>

<p><strong>네트워크 지식:</strong></p>
<ul>
  <li>TCP/IP 기본 개념</li>
  <li>HTTP/HTTPS 프로토콜</li>
  <li>DNS 기본 개념 (도메인 사용 시)</li>
</ul>

<p><strong>보안 지식:</strong></p>
<ul>
  <li>SSH 키 기반 인증</li>
  <li>방화벽 기본 개념</li>
  <li>SSL/TLS 인증서 개념</li>
</ul>

<h3 id="아키텍처-개요">아키텍처 개요</h3>

<p>프로덕션 환경에서의 FastAPI 배포 아키텍처:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>인터넷
  ↓
[AWS 보안 그룹] → 포트 80, 443 허용
  ↓
[Nginx 리버스 프록시] → 포트 80/443
  ↓
[Uvicorn (FastAPI)] → 포트 8000 (로컬)
  ↓
[systemd] → 프로세스 관리 및 자동 재시작
</code></pre></div></div>

<p><strong>주요 구성 요소:</strong></p>
<ul>
  <li><strong>Nginx</strong>: 정적 파일 서빙, SSL 종료, 로드 밸런싱, 보안 헤더</li>
  <li><strong>Uvicorn</strong>: ASGI 서버, FastAPI 애플리케이션 실행</li>
  <li><strong>systemd</strong>: 서비스 자동 시작, 재시작, 로그 관리</li>
  <li><strong>UFW</strong>: 호스트 기반 방화벽</li>
  <li><strong>Let’s Encrypt</strong>: 무료 SSL/TLS 인증서</li>
</ul>

<hr />

<h2 id="환경-준비">환경 준비</h2>

<h3 id="ec2-인스턴스-생성">EC2 인스턴스 생성</h3>

<p><strong>인스턴스 스펙 선택:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AMI: Ubuntu Server 24.04.2 LTS (HVM), SSD Volume Type
인스턴스 유형: t2.micro (프리티어) 또는 t2.small (권장)
스토리지: 최소 8GB (권장 20GB 이상)
</code></pre></div></div>

<p><strong>인스턴스 생성 과정:</strong></p>

<ol>
  <li>AWS Console → EC2 → 인스턴스 시작</li>
  <li>Ubuntu 24.04.2 LTS AMI 선택</li>
  <li>인스턴스 유형 선택 (CPU, 메모리 고려)</li>
  <li>키 페어 생성/선택 (.pem 파일 다운로드 및 안전하게 보관)</li>
  <li>네트워크 설정 - 나중에 보안 그룹 구성</li>
  <li>스토리지 구성 - 최소 8GB gp3 볼륨</li>
  <li>고급 세부 정보 - IAM 역할 필요 시 설정</li>
</ol>

<p><strong>Elastic IP 할당 (프로덕션 권장):</strong></p>

<p>고정 IP 주소가 필요한 경우:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># AWS Console에서</span>
EC2 → 탄력적 IP → 주소 할당 → 인스턴스에 연결
</code></pre></div></div>

<p>이를 통해 인스턴스 재시작 시에도 동일한 IP 주소를 유지할 수 있습니다.</p>

<h3 id="ec2-인스턴스-접속">EC2 인스턴스 접속</h3>

<p><strong>SSH 키 권한 설정 (최초 1회):</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Linux/macOS</span>
<span class="nb">chmod </span>400 /경로/열쇠파일.pem

<span class="c"># Windows PowerShell</span>
icacls <span class="s2">"C:</span><span class="se">\경</span><span class="s2">로</span><span class="se">\열</span><span class="s2">쇠파일.pem"</span> /inheritance:r
icacls <span class="s2">"C:</span><span class="se">\경</span><span class="s2">로</span><span class="se">\열</span><span class="s2">쇠파일.pem"</span> /grant:r <span class="s2">"%USERNAME%:R"</span>
</code></pre></div></div>

<p><strong>SSH 접속:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-i</span> /경로/열쇠파일.pem ubuntu@인스턴스IP

<span class="c"># 예시 (Linux/macOS)</span>
ssh <span class="nt">-i</span> /Users/pem/my_proton_key.pem ubuntu@13.124.216.216

<span class="c"># 예시 (Windows)</span>
ssh <span class="nt">-i</span> C:<span class="se">\U</span>sers<span class="se">\m</span>y<span class="se">\p</span>em<span class="se">\m</span>y_proton_key.pem ubuntu@13.124.216.216
</code></pre></div></div>

<p><strong>SSH 접속 간소화 (.ssh/config 설정):</strong></p>

<p>로컬 머신의 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 파일에 다음 내용 추가:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host aws-fastapi
    HostName 13.124.216.216
    User ubuntu
    IdentityFile /경로/열쇠파일.pem
    ServerAliveInterval 60
</code></pre></div></div>

<p>이제 <code class="language-plaintext highlighter-rouge">ssh aws-fastapi</code>만으로 접속 가능합니다.</p>

<h3 id="초기-시스템-업데이트">초기 시스템 업데이트</h3>

<p>인스턴스 접속 후 시스템 업데이트를 진행합니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt upgrade <span class="nt">-y</span>
<span class="nb">sudo </span>apt autoremove <span class="nt">-y</span>
</code></pre></div></div>

<p><strong>시스템 시간대 설정:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 현재 시간대 확인</span>
timedatectl

<span class="c"># 서울 시간대로 설정</span>
<span class="nb">sudo </span>timedatectl set-timezone Asia/Seoul

<span class="c"># 확인</span>
timedatectl
</code></pre></div></div>

<hr />

<h2 id="python-및-필수-패키지-설치">Python 및 필수 패키지 설치</h2>

<h3 id="python-설치-및-버전-확인">Python 설치 및 버전 확인</h3>

<p>Ubuntu 24.04 LTS는 Python 3.12가 기본 설치되어 있습니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Python 버전 확인</span>
python3 <span class="nt">--version</span>

<span class="c"># 출력 예: Python 3.12.3</span>
</code></pre></div></div>

<h3 id="필수-개발-도구-설치">필수 개발 도구 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\</span>
    python3 <span class="se">\</span>
    python3-venv <span class="se">\</span>
    python3-pip <span class="se">\</span>
    python3-dev <span class="se">\</span>
    build-essential <span class="se">\</span>
    libssl-dev <span class="se">\</span>
    libffi-dev <span class="se">\</span>
    git <span class="se">\</span>
    curl <span class="se">\</span>
    wget
</code></pre></div></div>

<p><strong>패키지 설명:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">python3-venv</code>: 가상환경 생성 도구</li>
  <li><code class="language-plaintext highlighter-rouge">python3-pip</code>: Python 패키지 관리자</li>
  <li><code class="language-plaintext highlighter-rouge">python3-dev</code>: Python C 확장 컴파일용 헤더</li>
  <li><code class="language-plaintext highlighter-rouge">build-essential</code>: C/C++ 컴파일러 및 make</li>
  <li><code class="language-plaintext highlighter-rouge">libssl-dev</code>, <code class="language-plaintext highlighter-rouge">libffi-dev</code>: 암호화 라이브러리 의존성</li>
  <li><code class="language-plaintext highlighter-rouge">git</code>: 버전 관리 (코드 배포 시 유용)</li>
  <li><code class="language-plaintext highlighter-rouge">curl</code>, <code class="language-plaintext highlighter-rouge">wget</code>: HTTP 클라이언트 도구</li>
</ul>

<h3 id="pip-업그레이드">pip 업그레이드</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-m</span> pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip
</code></pre></div></div>

<hr />

<h2 id="프로젝트-디렉터리-구성">프로젝트 디렉터리 구성</h2>

<h3 id="디렉터리-생성">디렉터리 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~
<span class="nb">mkdir</span> <span class="nt">-p</span> reactbase/public
<span class="nb">cd </span>reactbase
</code></pre></div></div>

<h3 id="프로젝트-구조">프로젝트 구조</h3>

<p>프로덕션 환경에서 권장하는 디렉터리 구조:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/ubuntu/reactbase/
├── venv/                # 가상환경
├── server.py            # FastAPI 애플리케이션
├── .env                 # 환경 변수 (민감 정보)
├── requirements.txt     # Python 의존성
├── public/              # 정적 파일 (이미지, CSS, JS 등)
│   ├── images/
│   ├── css/
│   └── js/
├── logs/                # 애플리케이션 로그 (선택사항)
└── tests/               # 테스트 코드 (선택사항)
</code></pre></div></div>

<h3 id="디렉터리-권한-설정">디렉터리 권한 설정</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 현재 사용자 소유로 설정</span>
<span class="nb">sudo chown</span> <span class="nt">-R</span> ubuntu:ubuntu /home/ubuntu/reactbase

<span class="c"># 디렉터리 권한 설정 (755)</span>
<span class="nb">chmod </span>755 /home/ubuntu/reactbase

<span class="c"># 정적 파일 디렉터리</span>
<span class="nb">chmod </span>755 /home/ubuntu/reactbase/public
</code></pre></div></div>

<hr />

<h2 id="가상환경-구성-및-fastapi-설치">가상환경 구성 및 FastAPI 설치</h2>

<h3 id="가상환경-생성-및-활성화">가상환경 생성 및 활성화</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 가상환경 생성</span>
python3 <span class="nt">-m</span> venv venv

<span class="c"># 가상환경 활성화</span>
<span class="nb">source </span>venv/bin/activate

<span class="c"># 활성화 확인 - 프롬프트 앞에 (venv) 표시</span>
<span class="o">(</span>venv<span class="o">)</span> ubuntu@ip-xxx:~/reactbase<span class="err">$</span>
</code></pre></div></div>

<p><strong>가상환경 사용 이유:</strong></p>
<ul>
  <li>시스템 Python과 프로젝트 의존성 분리</li>
  <li>프로젝트별 독립적인 패키지 버전 관리</li>
  <li>권한 문제 방지 (sudo 없이 패키지 설치 가능)</li>
</ul>

<h3 id="fastapi-및-필수-패키지-설치">FastAPI 및 필수 패키지 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 패키지 설치</span>
pip <span class="nb">install </span>fastapi uvicorn[standard]

<span class="c"># 추가 유용한 패키지</span>
pip <span class="nb">install</span> <span class="se">\</span>
    python-dotenv <span class="se">\</span>
    pydantic[email] <span class="se">\</span>
    python-multipart <span class="se">\</span>
    aiofiles
</code></pre></div></div>

<p><strong>패키지 설명:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">fastapi</code>: 웹 프레임워크</li>
  <li><code class="language-plaintext highlighter-rouge">uvicorn[standard]</code>: ASGI 서버 (HTTP/WebSocket 지원, 성능 최적화 포함)</li>
  <li><code class="language-plaintext highlighter-rouge">python-dotenv</code>: .env 파일에서 환경 변수 로드</li>
  <li><code class="language-plaintext highlighter-rouge">pydantic[email]</code>: 데이터 검증 (이메일 검증 포함)</li>
  <li><code class="language-plaintext highlighter-rouge">python-multipart</code>: 파일 업로드 지원</li>
  <li><code class="language-plaintext highlighter-rouge">aiofiles</code>: 비동기 파일 I/O</li>
</ul>

<h3 id="requirementstxt-생성">requirements.txt 생성</h3>

<p>의존성 관리를 위해 설치된 패키지 목록을 저장:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip freeze <span class="o">&gt;</span> requirements.txt
</code></pre></div></div>

<p><strong>requirements.txt 내용 예시:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fastapi==0.109.0
uvicorn[standard]==0.27.0
python-dotenv==1.0.0
pydantic[email]==2.5.0
python-multipart==0.0.6
aiofiles==23.2.1
</code></pre></div></div>

<h3 id="가상환경-비활성화">가상환경 비활성화</h3>

<p>작업 완료 후 가상환경 종료:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deactivate
</code></pre></div></div>

<hr />

<h2 id="fastapi-애플리케이션-코드">FastAPI 애플리케이션 코드</h2>

<h3 id="기본-serverpy">기본 server.py</h3>

<p><code class="language-plaintext highlighter-rouge">/home/ubuntu/reactbase/server.py</code> 파일 생성:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span><span class="p">,</span> <span class="n">Request</span>
<span class="kn">from</span> <span class="n">fastapi.responses</span> <span class="kn">import</span> <span class="n">PlainTextResponse</span><span class="p">,</span> <span class="n">JSONResponse</span>
<span class="kn">from</span> <span class="n">fastapi.staticfiles</span> <span class="kn">import</span> <span class="n">StaticFiles</span>
<span class="kn">from</span> <span class="n">fastapi.middleware.cors</span> <span class="kn">import</span> <span class="n">CORSMiddleware</span>
<span class="kn">from</span> <span class="n">fastapi.middleware.trustedhost</span> <span class="kn">import</span> <span class="n">TrustedHostMiddleware</span>
<span class="kn">import</span> <span class="n">uvicorn</span>
<span class="kn">import</span> <span class="n">pathlib</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">from</span> <span class="n">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="c1"># 환경 변수 로드 (선택사항)
</span><span class="kn">from</span> <span class="n">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
<span class="nf">load_dotenv</span><span class="p">()</span>

<span class="c1"># FastAPI 앱 초기화
</span><span class="n">app</span> <span class="o">=</span> <span class="nc">FastAPI</span><span class="p">(</span>
    <span class="n">title</span><span class="o">=</span><span class="sh">"</span><span class="s">FastAPI Production Server</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">AWS EC2에 배포된 프로덕션 FastAPI 서버</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="sh">"</span><span class="s">1.0.0</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">docs_url</span><span class="o">=</span><span class="sh">"</span><span class="s">/docs</span><span class="sh">"</span><span class="p">,</span>  <span class="c1"># Swagger UI
</span>    <span class="n">redoc_url</span><span class="o">=</span><span class="sh">"</span><span class="s">/redoc</span><span class="sh">"</span>  <span class="c1"># ReDoc
</span><span class="p">)</span>

<span class="c1"># CORS 설정 (필요한 경우)
</span><span class="n">app</span><span class="p">.</span><span class="nf">add_middleware</span><span class="p">(</span>
    <span class="n">CORSMiddleware</span><span class="p">,</span>
    <span class="n">allow_origins</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">],</span>  <span class="c1"># 프로덕션에서는 특정 도메인만 허용
</span>    <span class="n">allow_credentials</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">allow_methods</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">],</span>
    <span class="n">allow_headers</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>

<span class="c1"># 신뢰할 수 있는 호스트 설정 (보안)
# app.add_middleware(
#     TrustedHostMiddleware,
#     allowed_hosts=["yourdomain.com", "www.yourdomain.com"]
# )
</span>
<span class="c1"># 헬스 체크 엔드포인트
</span><span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/health</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">JSONResponse</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">health_check</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">서버 상태 확인용 헬스 체크 엔드포인트</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="sh">"</span><span class="s">status</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">healthy</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">timestamp</span><span class="sh">"</span><span class="p">:</span> <span class="n">datetime</span><span class="p">.</span><span class="nf">utcnow</span><span class="p">().</span><span class="nf">isoformat</span><span class="p">(),</span>
        <span class="sh">"</span><span class="s">version</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">1.0.0</span><span class="sh">"</span>
    <span class="p">}</span>

<span class="c1"># 기본 엔드포인트
</span><span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">PlainTextResponse</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_root</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">루트 경로</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">Welcome to FastAPI Production Server</span><span class="sh">"</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/hello</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">PlainTextResponse</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_hello</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Hello 엔드포인트</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">hello</span><span class="sh">"</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/world</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">PlainTextResponse</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_world</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">World 엔드포인트</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">world</span><span class="sh">"</span>

<span class="c1"># API 엔드포인트 예시
</span><span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/api/info</span><span class="sh">"</span><span class="p">,</span> <span class="n">response_class</span><span class="o">=</span><span class="n">JSONResponse</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">api_info</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">서버 정보 반환</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="sh">"</span><span class="s">server</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">FastAPI</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">python_version</span><span class="sh">"</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">version</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">environment</span><span class="sh">"</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="nf">getenv</span><span class="p">(</span><span class="sh">"</span><span class="s">ENVIRONMENT</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">production</span><span class="sh">"</span><span class="p">)</span>
    <span class="p">}</span>

<span class="c1"># 정적 파일 서빙
</span><span class="n">static_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="p">.</span><span class="nc">Path</span><span class="p">(</span><span class="n">__file__</span><span class="p">).</span><span class="nf">resolve</span><span class="p">().</span><span class="n">parent</span>
<span class="n">public_dir</span> <span class="o">=</span> <span class="n">static_dir</span> <span class="o">/</span> <span class="sh">"</span><span class="s">public</span><span class="sh">"</span>

<span class="k">if</span> <span class="n">public_dir</span><span class="p">.</span><span class="nf">exists</span><span class="p">():</span>
<span class="n">app</span><span class="p">.</span><span class="nf">mount</span><span class="p">(</span><span class="sh">"</span><span class="s">/images</span><span class="sh">"</span><span class="p">,</span> <span class="nc">StaticFiles</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="n">public_dir</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">images</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">app</span><span class="p">.</span><span class="nf">mount</span><span class="p">(</span><span class="sh">"</span><span class="s">/static</span><span class="sh">"</span><span class="p">,</span> <span class="nc">StaticFiles</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="n">public_dir</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">static</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># 에러 핸들러
</span><span class="nd">@app.exception_handler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">not_found_handler</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
    <span class="k">return</span> <span class="nc">JSONResponse</span><span class="p">(</span>
        <span class="n">status_code</span><span class="o">=</span><span class="mi">404</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">detail</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">요청한 리소스를 찾을 수 없습니다.</span><span class="sh">"</span><span class="p">}</span>
    <span class="p">)</span>

<span class="nd">@app.exception_handler</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">internal_error_handler</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
    <span class="k">return</span> <span class="nc">JSONResponse</span><span class="p">(</span>
        <span class="n">status_code</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">detail</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">서버 내부 오류가 발생했습니다.</span><span class="sh">"</span><span class="p">}</span>
    <span class="p">)</span>

<span class="c1"># 애플리케이션 시작/종료 이벤트
</span><span class="nd">@app.on_event</span><span class="p">(</span><span class="sh">"</span><span class="s">startup</span><span class="sh">"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">startup_event</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">앱 시작 시 실행</span><span class="sh">"""</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">FastAPI 서버 시작됨</span><span class="sh">"</span><span class="p">)</span>

<span class="nd">@app.on_event</span><span class="p">(</span><span class="sh">"</span><span class="s">shutdown</span><span class="sh">"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">shutdown_event</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">앱 종료 시 실행</span><span class="sh">"""</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">FastAPI 서버 종료됨</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># 직접 실행 시 (개발 환경용)
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">uvicorn</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span>
        <span class="n">app</span><span class="p">,</span>
        <span class="n">host</span><span class="o">=</span><span class="sh">"</span><span class="s">0.0.0.0</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">port</span><span class="o">=</span><span class="mi">8000</span><span class="p">,</span>
        <span class="n">log_level</span><span class="o">=</span><span class="sh">"</span><span class="s">info</span><span class="sh">"</span>
    <span class="p">)</span>
</code></pre></div></div>

<h3 id="파일-생성-방법">파일 생성 방법</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /home/ubuntu/reactbase
nano server.py
<span class="c"># 위 코드를 복사 붙여넣기</span>
<span class="c"># Ctrl+O (저장), Ctrl+X (종료)</span>
</code></pre></div></div>

<h3 id="코드-주요-특징">코드 주요 특징</h3>

<p><strong>프로덕션 준비:</strong></p>
<ul>
  <li>헬스 체크 엔드포인트 (<code class="language-plaintext highlighter-rouge">/health</code>)</li>
  <li>CORS 미들웨어 설정</li>
  <li>에러 핸들러 구현</li>
  <li>시작/종료 이벤트 핸들러</li>
</ul>

<p><strong>보안:</strong></p>
<ul>
  <li>TrustedHostMiddleware 옵션 (필요 시 활성화)</li>
  <li>환경 변수를 통한 설정 관리</li>
</ul>

<p><strong>문서화:</strong></p>
<ul>
  <li>Swagger UI (<code class="language-plaintext highlighter-rouge">/docs</code>)</li>
  <li>ReDoc (<code class="language-plaintext highlighter-rouge">/redoc</code>)</li>
</ul>

<hr />

<h2 id="서버-실행-테스트">서버 실행 테스트</h2>

<h3 id="개발-모드로-서버-실행">개발 모드로 서버 실행</h3>

<p>가상환경 활성화 후 FastAPI 서버를 테스트 실행합니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /home/ubuntu/reactbase
<span class="nb">source </span>venv/bin/activate
python3 server.py
</code></pre></div></div>

<p><strong>또는 uvicorn 직접 실행:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uvicorn server:app <span class="nt">--host</span> 0.0.0.0 <span class="nt">--port</span> 8000
</code></pre></div></div>

<p><strong>개발 모드 (자동 리로드 활성화):</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uvicorn server:app <span class="nt">--host</span> 0.0.0.0 <span class="nt">--port</span> 8000 <span class="nt">--reload</span>
</code></pre></div></div>

<h3 id="정상-실행-확인">정상 실행 확인</h3>

<p>콘솔에 다음과 같은 로그가 출력되면 정상입니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INFO:     Started server process [12345]
INFO:     Waiting for application startup.
FastAPI 서버 시작됨
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
</code></pre></div></div>

<h3 id="로컬에서-테스트">로컬에서 테스트</h3>

<p>SSH 세션 내에서 curl로 테스트:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 새 터미널 열기 (또는 서버를 백그라운드로 실행)</span>
curl http://localhost:8000/
<span class="c"># 출력: Welcome to FastAPI Production Server</span>

curl http://localhost:8000/health
<span class="c"># 출력: {"status":"healthy","timestamp":"...","version":"1.0.0"}</span>
</code></pre></div></div>

<h3 id="외부에서-접속-테스트">외부에서 접속 테스트</h3>

<p>브라우저 또는 로컬 터미널에서:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://인스턴스_퍼블릭IP:8000
http://인스턴스_퍼블릭IP:8000/docs  <span class="c"># Swagger UI</span>
http://인스턴스_퍼블릭IP:8000/health
</code></pre></div></div>

<p><strong>접속이 안 된다면:</strong></p>
<ol>
  <li>AWS 보안 그룹에서 8000 포트가 열려있는지 확인</li>
  <li>UFW 방화벽 확인 (설정한 경우)</li>
  <li>로컬 네트워크 방화벽 확인</li>
</ol>

<h3 id="서버-중지">서버 중지</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Ctrl+C로 중지</span>
<span class="c"># 또는 프로세스 찾아서 종료</span>
ps aux | <span class="nb">grep </span>uvicorn
<span class="nb">kill</span> &lt;PID&gt;
</code></pre></div></div>

<hr />

<h2 id="aws-보안-그룹-설정">AWS 보안 그룹 설정</h2>

<p>AWS 보안 그룹은 EC2 인스턴스의 가상 방화벽 역할을 합니다. 외부에서 서버에 접근하려면 필요한 포트를 열어야 합니다.</p>

<h3 id="보안-그룹-인바운드-규칙-설정">보안 그룹 인바운드 규칙 설정</h3>

<p><strong>AWS Console에서 설정:</strong></p>

<ol>
  <li>EC2 Dashboard → 인스턴스 선택</li>
  <li>보안 탭 → 보안 그룹 클릭</li>
  <li>인바운드 규칙 편집</li>
</ol>

<p><strong>필수 규칙:</strong></p>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>프로토콜</th>
      <th>포트 범위</th>
      <th>소스</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SSH</td>
      <td>TCP</td>
      <td>22</td>
      <td>My IP 또는 특정 IP</td>
      <td>SSH 접속</td>
    </tr>
    <tr>
      <td>사용자 지정 TCP</td>
      <td>TCP</td>
      <td>8000</td>
      <td>0.0.0.0/0</td>
      <td>FastAPI 직접 접근 (개발)</td>
    </tr>
    <tr>
      <td>HTTP</td>
      <td>TCP</td>
      <td>80</td>
      <td>0.0.0.0/0</td>
      <td>Nginx HTTP</td>
    </tr>
    <tr>
      <td>HTTPS</td>
      <td>TCP</td>
      <td>443</td>
      <td>0.0.0.0/0</td>
      <td>Nginx HTTPS</td>
    </tr>
  </tbody>
</table>

<p><strong>보안 권장사항:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>개발 단계: 8000 포트 개방 (0.0.0.0/0)
프로덕션 단계: 8000 포트 차단, 80/443만 개방
  → Nginx를 통해서만 FastAPI 접근 허용
</code></pre></div></div>

<h3 id="ip-화이트리스트-설정-선택사항">IP 화이트리스트 설정 (선택사항)</h3>

<p>SSH 접근을 특정 IP로 제한:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>유형: SSH
프로토콜: TCP
포트: 22
소스: 123.456.789.0/32 (귀하의 고정 IP)
설명: Office IP only
</code></pre></div></div>

<h3 id="아웃바운드-규칙-확인">아웃바운드 규칙 확인</h3>

<p>기본적으로 모든 아웃바운드 트래픽이 허용되어 있습니다. 보안 강화가 필요한 경우 다음만 허용:</p>

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>프로토콜</th>
      <th>포트 범위</th>
      <th>대상</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HTTP</td>
      <td>TCP</td>
      <td>80</td>
      <td>0.0.0.0/0</td>
      <td>패키지 다운로드</td>
    </tr>
    <tr>
      <td>HTTPS</td>
      <td>TCP</td>
      <td>443</td>
      <td>0.0.0.0/0</td>
      <td>보안 통신</td>
    </tr>
    <tr>
      <td>DNS (UDP)</td>
      <td>UDP</td>
      <td>53</td>
      <td>0.0.0.0/0</td>
      <td>DNS 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="최소-권한-원칙">최소 권한 원칙</h3>

<p>프로덕션 환경에서는 다음 원칙을 따릅니다:</p>

<ol>
  <li><strong>SSH는 신뢰할 수 있는 IP만 허용</strong></li>
  <li><strong>애플리케이션 포트(8000)는 로컬호스트만 접근</strong> (Nginx 사용 시)</li>
  <li><strong>80/443 포트만 인터넷에 개방</strong></li>
  <li><strong>불필요한 포트는 모두 차단</strong></li>
</ol>

<h3 id="cli로-보안-그룹-설정">CLI로 보안 그룹 설정</h3>

<p>AWS CLI를 사용하는 경우:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 보안 그룹 ID 확인</span>
aws ec2 describe-security-groups

<span class="c"># 인바운드 규칙 추가 (포트 8000)</span>
aws ec2 authorize-security-group-ingress <span class="se">\</span>
    <span class="nt">--group-id</span> sg-xxxxxxxxx <span class="se">\</span>
    <span class="nt">--protocol</span> tcp <span class="se">\</span>
    <span class="nt">--port</span> 8000 <span class="se">\</span>
    <span class="nt">--cidr</span> 0.0.0.0/0
</code></pre></div></div>

<hr />

<h2 id="systemd를-통한-자동-실행-설정">systemd를 통한 자동 실행 설정</h2>

<p>systemd는 Linux 시스템의 서비스 관리자로, 프로세스의 시작, 중지, 재시작 및 자동 실행을 관리합니다.</p>

<h3 id="systemd-서비스-파일-생성">systemd 서비스 파일 생성</h3>

<p><code class="language-plaintext highlighter-rouge">/etc/systemd/system/fastapi.service</code> 파일을 생성합니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/systemd/system/fastapi.service
</code></pre></div></div>

<p><strong>기본 설정:</strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[Unit]</span><span class="w">
</span><span class="py">Description</span><span class="p">=</span><span class="s">FastAPI Application Server</span>
<span class="py">After</span><span class="p">=</span><span class="s">network.target</span>
<span class="py">Documentation</span><span class="p">=</span><span class="s">https://fastapi.tiangolo.com/</span>
<span class="w">
</span><span class="nn">[Service]</span><span class="w">
</span><span class="py">Type</span><span class="p">=</span><span class="s">notify</span>
<span class="py">User</span><span class="p">=</span><span class="s">ubuntu</span>
<span class="py">Group</span><span class="p">=</span><span class="s">ubuntu</span>
<span class="py">WorkingDirectory</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase</span>
<span class="py">Environment</span><span class="p">=</span><span class="s">"PATH=/home/ubuntu/reactbase/venv/bin"</span>
<span class="py">EnvironmentFile</span><span class="p">=</span><span class="s">-/home/ubuntu/reactbase/.env</span>
<span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app --host 0.0.0.0 --port 8000</span>
<span class="py">ExecReload</span><span class="p">=</span><span class="s">/bin/kill -HUP $MAINPID</span>
<span class="py">Restart</span><span class="p">=</span><span class="s">always</span>
<span class="py">RestartSec</span><span class="p">=</span><span class="s">3</span>
<span class="py">StandardOutput</span><span class="p">=</span><span class="s">append:/var/log/fastapi/access.log</span>
<span class="py">StandardError</span><span class="p">=</span><span class="s">append:/var/log/fastapi/error.log</span>
<span class="w">
</span><span class="c"># 보안 설정
</span><span class="py">NoNewPrivileges</span><span class="p">=</span><span class="s">true</span>
<span class="py">PrivateTmp</span><span class="p">=</span><span class="s">true</span>
<span class="w">
</span><span class="c"># 리소스 제한
</span><span class="py">LimitNOFILE</span><span class="p">=</span><span class="s">65536</span>
<span class="py">TimeoutStopSec</span><span class="p">=</span><span class="s">30</span>
<span class="w">
</span><span class="nn">[Install]</span><span class="w">
</span><span class="py">WantedBy</span><span class="p">=</span><span class="s">multi-user.target</span>
</code></pre></div></div>

<p><strong>프로덕션 설정 (Multi-worker):</strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[Unit]</span><span class="w">
</span><span class="py">Description</span><span class="p">=</span><span class="s">FastAPI Application Server (Production)</span>
<span class="py">After</span><span class="p">=</span><span class="s">network.target</span>
<span class="py">Documentation</span><span class="p">=</span><span class="s">https://fastapi.tiangolo.com/</span>
<span class="w">
</span><span class="nn">[Service]</span><span class="w">
</span><span class="py">Type</span><span class="p">=</span><span class="s">notify</span>
<span class="py">User</span><span class="p">=</span><span class="s">ubuntu</span>
<span class="py">Group</span><span class="p">=</span><span class="s">ubuntu</span>
<span class="py">WorkingDirectory</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase</span>
<span class="py">Environment</span><span class="p">=</span><span class="s">"PATH=/home/ubuntu/reactbase/venv/bin"</span>
<span class="py">EnvironmentFile</span><span class="p">=</span><span class="s">-/home/ubuntu/reactbase/.env</span>
<span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app </span><span class="se">\
</span><span class="w">    </span><span class="s">--host 0.0.0.0 </span><span class="se">\
</span><span class="w">    </span><span class="s">--port 8000 </span><span class="se">\
</span><span class="w">    </span><span class="s">--workers 4 </span><span class="se">\
</span><span class="w">    </span><span class="s">--log-level info </span><span class="se">\
</span><span class="w">    </span><span class="s">--access-log </span><span class="se">\
</span><span class="w">    </span><span class="s">--proxy-headers </span><span class="se">\
</span><span class="w">    </span><span class="s">--forwarded-allow-ips='*'</span>
<span class="py">ExecReload</span><span class="p">=</span><span class="s">/bin/kill -HUP $MAINPID</span>
<span class="py">Restart</span><span class="p">=</span><span class="s">on-failure</span>
<span class="py">RestartSec</span><span class="p">=</span><span class="s">5s</span>
<span class="py">StandardOutput</span><span class="p">=</span><span class="s">journal</span>
<span class="py">StandardError</span><span class="p">=</span><span class="s">journal</span>
<span class="py">SyslogIdentifier</span><span class="p">=</span><span class="s">fastapi</span>
<span class="w">
</span><span class="c"># 보안 강화
</span><span class="py">NoNewPrivileges</span><span class="p">=</span><span class="s">true</span>
<span class="py">PrivateTmp</span><span class="p">=</span><span class="s">true</span>
<span class="py">ProtectSystem</span><span class="p">=</span><span class="s">strict</span>
<span class="py">ProtectHome</span><span class="p">=</span><span class="s">read-only</span>
<span class="py">ReadWritePaths</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase</span>
<span class="w">
</span><span class="c"># 리소스 제한
</span><span class="py">LimitNOFILE</span><span class="p">=</span><span class="s">65536</span>
<span class="py">LimitNPROC</span><span class="p">=</span><span class="s">512</span>
<span class="w">
</span><span class="nn">[Install]</span><span class="w">
</span><span class="py">WantedBy</span><span class="p">=</span><span class="s">multi-user.target</span>
</code></pre></div></div>

<h3 id="서비스-파일-옵션-설명">서비스 파일 옵션 설명</h3>

<p><strong>[Unit] 섹션:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Description</code>: 서비스 설명</li>
  <li><code class="language-plaintext highlighter-rouge">After</code>: 네트워크가 준비된 후 시작</li>
  <li><code class="language-plaintext highlighter-rouge">Documentation</code>: 문서 URL</li>
</ul>

<p><strong>[Service] 섹션:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Type=notify</code>: systemd에 시작 완료 알림</li>
  <li><code class="language-plaintext highlighter-rouge">User/Group</code>: 실행 사용자/그룹</li>
  <li><code class="language-plaintext highlighter-rouge">WorkingDirectory</code>: 작업 디렉터리</li>
  <li><code class="language-plaintext highlighter-rouge">Environment</code>: 환경 변수 설정</li>
  <li><code class="language-plaintext highlighter-rouge">EnvironmentFile</code>: .env 파일 로드 (-는 파일 없어도 에러 안남)</li>
  <li><code class="language-plaintext highlighter-rouge">ExecStart</code>: 실행 명령어</li>
  <li><code class="language-plaintext highlighter-rouge">ExecReload</code>: 리로드 명령어 (HUP 시그널)</li>
  <li><code class="language-plaintext highlighter-rouge">Restart=always</code>: 항상 재시작 (on-failure는 실패 시만)</li>
  <li><code class="language-plaintext highlighter-rouge">RestartSec</code>: 재시작 대기 시간</li>
  <li><code class="language-plaintext highlighter-rouge">StandardOutput/StandardError</code>: 로그 출력 위치</li>
</ul>

<p><strong>보안 옵션:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">NoNewPrivileges</code>: 권한 상승 방지</li>
  <li><code class="language-plaintext highlighter-rouge">PrivateTmp</code>: 독립적인 /tmp 사용</li>
  <li><code class="language-plaintext highlighter-rouge">ProtectSystem</code>: 시스템 디렉터리 보호</li>
  <li><code class="language-plaintext highlighter-rouge">ProtectHome</code>: 홈 디렉터리 보호</li>
</ul>

<p><strong>리소스 제한:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">LimitNOFILE</code>: 파일 디스크립터 제한</li>
  <li><code class="language-plaintext highlighter-rouge">LimitNPROC</code>: 프로세스 수 제한</li>
</ul>

<h3 id="worker-수-계산">Worker 수 계산</h3>

<p>CPU 코어 기반 권장 worker 수:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># CPU 코어 수 확인</span>
<span class="nb">nproc</span>

<span class="c"># 권장 worker 수 = (CPU 코어 수 × 2) + 1</span>
<span class="c"># 예: 2 코어 → (2 × 2) + 1 = 5 workers</span>
</code></pre></div></div>

<h3 id="로그-디렉터리-생성">로그 디렉터리 생성</h3>

<p>StandardOutput/StandardError에 파일 로그를 사용하는 경우:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/log/fastapi
<span class="nb">sudo chown </span>ubuntu:ubuntu /var/log/fastapi
<span class="nb">sudo chmod </span>755 /var/log/fastapi
</code></pre></div></div>

<hr />

<h3 id="systemd-서비스-등록-및-활성화">systemd 서비스 등록 및 활성화</h3>

<p><strong>서비스 등록 단계:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. systemd에 새 서비스 파일 인식</span>
<span class="nb">sudo </span>systemctl daemon-reload

<span class="c"># 2. 부팅 시 자동 시작 활성화</span>
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>fastapi.service

<span class="c"># 3. 서비스 즉시 시작</span>
<span class="nb">sudo </span>systemctl start fastapi.service

<span class="c"># 4. 서비스 상태 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service
</code></pre></div></div>

<p><strong>정상 실행 시 출력:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>● fastapi.service - FastAPI Application Server
     Loaded: loaded (/etc/systemd/system/fastapi.service; enabled; vendor preset: enabled)
     Active: active (running) since Fri 2025-10-11 10:30:00 KST; 5s ago
       Docs: https://fastapi.tiangolo.com/
   Main PID: 12345 (uvicorn)
      Tasks: 5 (limit: 4915)
     Memory: 50.2M
     CGroup: /system.slice/fastapi.service
             ├─12345 /home/ubuntu/reactbase/venv/bin/python3 /home/ubuntu/reactbase/venv/bin/uvicorn...
             ├─12346 /home/ubuntu/reactbase/venv/bin/python3 -c from multiprocessing.resource_tracker...
             └─12347 /home/ubuntu/reactbase/venv/bin/python3 -c from multiprocessing.spawn import...

Oct 11 10:30:00 systemd[1]: Started FastAPI Application Server.
Oct 11 10:30:00 uvicorn[12345]: INFO:     Started server process [12345]
Oct 11 10:30:00 uvicorn[12345]: INFO:     Waiting for application startup.
Oct 11 10:30:00 uvicorn[12345]: INFO:     Application startup complete.
Oct 11 10:30:00 uvicorn[12345]: INFO:     Uvicorn running on http://0.0.0.0:8000
</code></pre></div></div>

<h3 id="systemd-서비스-관리-명령어">systemd 서비스 관리 명령어</h3>

<p><strong>상태 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 서비스 상태</span>
<span class="nb">sudo </span>systemctl status fastapi.service

<span class="c"># 실행 여부만 확인</span>
<span class="nb">sudo </span>systemctl is-active fastapi.service

<span class="c"># 자동 시작 활성화 여부</span>
<span class="nb">sudo </span>systemctl is-enabled fastapi.service
</code></pre></div></div>

<p><strong>서비스 제어:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 서비스 시작</span>
<span class="nb">sudo </span>systemctl start fastapi.service

<span class="c"># 서비스 중지</span>
<span class="nb">sudo </span>systemctl stop fastapi.service

<span class="c"># 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service

<span class="c"># 서비스 리로드 (다운타임 없이)</span>
<span class="nb">sudo </span>systemctl reload fastapi.service

<span class="c"># 부팅 시 자동 시작 활성화</span>
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>fastapi.service

<span class="c"># 부팅 시 자동 시작 비활성화</span>
<span class="nb">sudo </span>systemctl disable fastapi.service
</code></pre></div></div>

<p><strong>서비스 파일 수정 후:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 서비스 파일 수정</span>
<span class="nb">sudo </span>nano /etc/systemd/system/fastapi.service

<span class="c"># 변경사항 적용</span>
<span class="nb">sudo </span>systemctl daemon-reload

<span class="c"># 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service
</code></pre></div></div>

<h3 id="서비스-의존성-확인">서비스 의존성 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 서비스 의존성 트리</span>
systemctl list-dependencies fastapi.service

<span class="c"># 서비스 시작 순서</span>
systemd-analyze critical-chain fastapi.service
</code></pre></div></div>

<hr />

<h3 id="재부팅-테스트">재부팅 테스트</h3>

<p>시스템 재부팅 후 자동 시작 확인:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 재부팅</span>
<span class="nb">sudo </span>reboot
</code></pre></div></div>

<p>재부팅 후 SSH 재접속 (약 1-2분 후):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-i</span> /경로/열쇠파일.pem ubuntu@인스턴스IP

<span class="c"># 서비스 상태 확인</span>
<span class="nb">sudo </span>systemctl status fastapi.service

<span class="c"># 서비스가 자동 시작되었는지 확인</span>
curl http://localhost:8000/health
</code></pre></div></div>

<hr />

<h2 id="환경-변수-관리">환경 변수 관리</h2>

<p>환경 변수를 사용하여 민감한 정보와 설정을 코드에서 분리합니다.</p>

<h3 id="env-파일-생성">.env 파일 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /home/ubuntu/reactbase
nano .env
</code></pre></div></div>

<p><strong>.env 파일 내용:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 환경 설정</span>
<span class="nv">ENVIRONMENT</span><span class="o">=</span>production
<span class="nv">DEBUG</span><span class="o">=</span>False

<span class="c"># 서버 설정</span>
<span class="nv">HOST</span><span class="o">=</span>0.0.0.0
<span class="nv">PORT</span><span class="o">=</span>8000
<span class="nv">WORKERS</span><span class="o">=</span>4

<span class="c"># 데이터베이스 (예시)</span>
<span class="nv">DATABASE_URL</span><span class="o">=</span>postgresql://user:password@localhost/dbname

<span class="c"># API 키 (예시)</span>
<span class="nv">SECRET_KEY</span><span class="o">=</span>your-secret-key-here-change-this
<span class="nv">API_KEY</span><span class="o">=</span>your-api-key-here

<span class="c"># CORS 설정</span>
<span class="nv">ALLOWED_ORIGINS</span><span class="o">=</span>https://yourdomain.com,https://www.yourdomain.com

<span class="c"># 로그 레벨</span>
<span class="nv">LOG_LEVEL</span><span class="o">=</span>info
</code></pre></div></div>

<h3 id="env-파일-권한-설정">.env 파일 권한 설정</h3>

<p>민감한 정보 보호를 위해 권한 제한:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod </span>600 /home/ubuntu/reactbase/.env
<span class="nb">chown </span>ubuntu:ubuntu /home/ubuntu/reactbase/.env
</code></pre></div></div>

<h3 id="fastapi-코드에서-환경-변수-사용">FastAPI 코드에서 환경 변수 사용</h3>

<p><strong>server.py 수정:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="kn">from</span> <span class="n">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>

<span class="nf">load_dotenv</span><span class="p">()</span>

<span class="c1"># 환경 변수 읽기
</span><span class="n">ENVIRONMENT</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">getenv</span><span class="p">(</span><span class="sh">"</span><span class="s">ENVIRONMENT</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">development</span><span class="sh">"</span><span class="p">)</span>
<span class="n">DEBUG</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">getenv</span><span class="p">(</span><span class="sh">"</span><span class="s">DEBUG</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">False</span><span class="sh">"</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">True</span><span class="sh">"</span>
<span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">getenv</span><span class="p">(</span><span class="sh">"</span><span class="s">SECRET_KEY</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">default-secret-key</span><span class="sh">"</span><span class="p">)</span>
<span class="n">DATABASE_URL</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">getenv</span><span class="p">(</span><span class="sh">"</span><span class="s">DATABASE_URL</span><span class="sh">"</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="nc">FastAPI</span><span class="p">(</span>
    <span class="n">title</span><span class="o">=</span><span class="sh">"</span><span class="s">FastAPI Server</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">debug</span><span class="o">=</span><span class="n">DEBUG</span>
<span class="p">)</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/config</span><span class="sh">"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_config</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="sh">"</span><span class="s">environment</span><span class="sh">"</span><span class="p">:</span> <span class="n">ENVIRONMENT</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">debug</span><span class="sh">"</span><span class="p">:</span> <span class="n">DEBUG</span>
        <span class="c1"># SECRET_KEY는 노출하지 않음
</span>    <span class="p">}</span>
</code></pre></div></div>

<h3 id="systemd에서-환경-변수-사용">systemd에서 환경 변수 사용</h3>

<p>systemd 서비스 파일에서 .env 로드:</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[Service]</span><span class="w">
</span><span class="py">EnvironmentFile</span><span class="p">=</span><span class="s">-/home/ubuntu/reactbase/.env</span>
</code></pre></div></div>

<p>또는 직접 환경 변수 설정:</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[Service]</span><span class="w">
</span><span class="py">Environment</span><span class="p">=</span><span class="s">"ENVIRONMENT=production"</span>
<span class="py">Environment</span><span class="p">=</span><span class="s">"DEBUG=False"</span>
<span class="py">Environment</span><span class="p">=</span><span class="s">"PORT=8000"</span>
</code></pre></div></div>

<h3 id="환경-변수-보안-best-practices">환경 변수 보안 Best Practices</h3>

<ol>
  <li><strong>.env 파일을 Git에 커밋하지 않기</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">".env"</span> <span class="o">&gt;&gt;</span> .gitignore
</code></pre></div>    </div>
  </li>
  <li><strong>.env.example 파일 제공</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> .env .env.example
<span class="c"># .env.example에서 실제 값 제거</span>
</code></pre></div>    </div>
  </li>
  <li><strong>최소 권한 원칙</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod </span>600 .env  <span class="c"># 소유자만 읽기/쓰기</span>
</code></pre></div>    </div>
  </li>
  <li><strong>암호화된 값 저장 (선택사항)</strong>
    <ul>
      <li>AWS Secrets Manager</li>
      <li>HashiCorp Vault</li>
      <li>환경 변수 암호화 도구</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="로그-관리-및-디버깅">로그 관리 및 디버깅</h2>

<h3 id="journalctl을-사용한-로그-조회">journalctl을 사용한 로그 조회</h3>

<p>systemd 서비스 로그는 journald에 저장됩니다.</p>

<p><strong>기본 로그 조회:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 전체 로그</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service

<span class="c"># 최근 로그만 (tail)</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-n</span> 50

<span class="c"># 실시간 로그 (follow)</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-f</span>

<span class="c"># 오늘의 로그만</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">--since</span> today

<span class="c"># 특정 시간 이후</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">--since</span> <span class="s2">"2025-10-11 10:00:00"</span>

<span class="c"># 특정 시간 범위</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">--since</span> <span class="s2">"1 hour ago"</span> <span class="nt">--until</span> <span class="s2">"now"</span>
</code></pre></div></div>

<p><strong>로그 필터링:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 에러만 표시</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-p</span> err

<span class="c"># 경고 이상 (warning, error, critical)</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-p</span> warning

<span class="c"># 특정 문자열 검색</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service | <span class="nb">grep</span> <span class="s2">"ERROR"</span>
</code></pre></div></div>

<p><strong>로그 형식 옵션:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># JSON 형식</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-o</span> json

<span class="c"># 자세한 정보</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-o</span> verbose

<span class="c"># 한 줄로 표시</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-o</span> short
</code></pre></div></div>

<h3 id="로그-레벨-설정">로그 레벨 설정</h3>

<p><strong>Uvicorn 로그 레벨:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># systemd 서비스 파일에서</span>
<span class="nv">ExecStart</span><span class="o">=</span>/home/ubuntu/reactbase/venv/bin/uvicorn server:app <span class="se">\</span>
    <span class="nt">--log-level</span> debug  <span class="c"># debug, info, warning, error, critical</span>
</code></pre></div></div>

<p><strong>Python logging 설정:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">logging</span>

<span class="c1"># 로그 설정
</span><span class="n">logging</span><span class="p">.</span><span class="nf">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">INFO</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="sh">'</span><span class="s">%(asctime)s - %(name)s - %(levelname)s - %(message)s</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">handlers</span><span class="o">=</span><span class="p">[</span>
        <span class="n">logging</span><span class="p">.</span><span class="nc">FileHandler</span><span class="p">(</span><span class="sh">'</span><span class="s">/var/log/fastapi/app.log</span><span class="sh">'</span><span class="p">),</span>
        <span class="n">logging</span><span class="p">.</span><span class="nc">StreamHandler</span><span class="p">()</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="nf">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/test</span><span class="sh">"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">Test endpoint called</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="sh">"</span><span class="s">Debug information</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">logger</span><span class="p">.</span><span class="nf">warning</span><span class="p">(</span><span class="sh">"</span><span class="s">Warning message</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sh">"</span><span class="s">Error occurred</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">status</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">ok</span><span class="sh">"</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="로그-로테이션">로그 로테이션</h3>

<p>journald는 자동으로 로그를 로테이션하지만, 파일 로그를 사용하는 경우 logrotate 설정:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/logrotate.d/fastapi
</code></pre></div></div>

<p><strong>logrotate 설정:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/var/log/fastapi/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 0640 ubuntu ubuntu
    sharedscripts
    postrotate
        systemctl reload fastapi.service &gt; /dev/null 2&gt;&amp;1 || true
    endscript
}
</code></pre></div></div>

<p><strong>옵션 설명:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">daily</code>: 매일 로테이션</li>
  <li><code class="language-plaintext highlighter-rouge">rotate 14</code>: 14개 백업 유지</li>
  <li><code class="language-plaintext highlighter-rouge">compress</code>: 압축 저장</li>
  <li><code class="language-plaintext highlighter-rouge">delaycompress</code>: 다음 로테이션 때 압축</li>
  <li><code class="language-plaintext highlighter-rouge">notifempty</code>: 빈 로그 파일 무시</li>
  <li><code class="language-plaintext highlighter-rouge">create</code>: 새 로그 파일 권한</li>
</ul>

<p><strong>로테이션 테스트:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>logrotate <span class="nt">-f</span> /etc/logrotate.d/fastapi
</code></pre></div></div>

<h3 id="일반적인-오류-패턴-및-해결">일반적인 오류 패턴 및 해결</h3>

<p><strong>1. 포트 이미 사용 중:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR: [Errno 98] Address already in use
</code></pre></div></div>

<p>해결:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 8000 포트 사용 중인 프로세스 찾기</span>
<span class="nb">sudo </span>lsof <span class="nt">-i</span> :8000
<span class="nb">sudo </span>netstat <span class="nt">-tulpn</span> | <span class="nb">grep</span> :8000

<span class="c"># 프로세스 종료</span>
<span class="nb">sudo kill</span> <span class="nt">-9</span> &lt;PID&gt;
</code></pre></div></div>

<p><strong>2. Permission denied:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PermissionError: [Errno 13] Permission denied
</code></pre></div></div>

<p>해결:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 파일/디렉터리 권한 확인</span>
<span class="nb">ls</span> <span class="nt">-la</span> /home/ubuntu/reactbase

<span class="c"># 권한 수정</span>
<span class="nb">sudo chown</span> <span class="nt">-R</span> ubuntu:ubuntu /home/ubuntu/reactbase
<span class="nb">chmod </span>755 /home/ubuntu/reactbase
</code></pre></div></div>

<p><strong>3. ModuleNotFoundError:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ModuleNotFoundError: No module named 'fastapi'
</code></pre></div></div>

<p>해결:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 가상환경 활성화 확인</span>
<span class="nb">source</span> /home/ubuntu/reactbase/venv/bin/activate

<span class="c"># 패키지 재설치</span>
pip <span class="nb">install </span>fastapi uvicorn
</code></pre></div></div>

<p><strong>4. 서비스 시작 실패:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상세 로그 확인</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-xe</span>

<span class="c"># 서비스 파일 문법 확인</span>
systemd-analyze verify /etc/systemd/system/fastapi.service
</code></pre></div></div>

<hr />

<h2 id="nginx-리버스-프록시-설정">Nginx 리버스 프록시 설정</h2>

<p>Nginx를 리버스 프록시로 사용하면 정적 파일 서빙, SSL 종료, 로드 밸런싱, 보안 향상 등의 이점을 얻을 수 있습니다.</p>

<h3 id="nginx-설치">Nginx 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> nginx
</code></pre></div></div>

<p><strong>Nginx 버전 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nginx <span class="nt">-v</span>
<span class="c"># 출력: nginx version: nginx/1.24.0 (Ubuntu)</span>
</code></pre></div></div>

<p><strong>Nginx 서비스 시작:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start nginx
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>nginx
<span class="nb">sudo </span>systemctl status nginx
</code></pre></div></div>

<h3 id="nginx-설정-파일-생성">Nginx 설정 파일 생성</h3>

<p>FastAPI 애플리케이션을 위한 Nginx 설정:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/nginx/sites-available/fastapi
</code></pre></div></div>

<p><strong>기본 설정 (HTTP):</strong></p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">your-domain.com</span> <span class="s">www.your-domain.com</span><span class="p">;</span>  <span class="c1"># 또는 IP 주소</span>
    
    <span class="kn">client_max_body_size</span> <span class="mi">50M</span><span class="p">;</span>  <span class="c1"># 최대 요청 크기</span>
    
    <span class="c1"># 액세스 로그</span>
    <span class="kn">access_log</span> <span class="n">/var/log/nginx/fastapi_access.log</span><span class="p">;</span>
    <span class="kn">error_log</span> <span class="n">/var/log/nginx/fastapi_error.log</span><span class="p">;</span>
    
    <span class="c1"># FastAPI 프록시</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8000</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-For</span> <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-Proto</span> <span class="nv">$scheme</span><span class="p">;</span>
        
        <span class="c1"># WebSocket 지원</span>
        <span class="kn">proxy_http_version</span> <span class="mf">1.1</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">"upgrade"</span><span class="p">;</span>
        
        <span class="c1"># 타임아웃 설정</span>
        <span class="kn">proxy_connect_timeout</span> <span class="s">60s</span><span class="p">;</span>
        <span class="kn">proxy_send_timeout</span> <span class="s">60s</span><span class="p">;</span>
        <span class="kn">proxy_read_timeout</span> <span class="s">60s</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1"># 정적 파일 직접 서빙 (성능 향상)</span>
    <span class="kn">location</span> <span class="n">/static/</span> <span class="p">{</span>
        <span class="kn">alias</span> <span class="n">/home/ubuntu/reactbase/public/</span><span class="p">;</span>
        <span class="kn">expires</span> <span class="s">30d</span><span class="p">;</span>
        <span class="kn">add_header</span> <span class="s">Cache-Control</span> <span class="s">"public,</span> <span class="s">immutable"</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kn">location</span> <span class="n">/images/</span> <span class="p">{</span>
        <span class="kn">alias</span> <span class="n">/home/ubuntu/reactbase/public/</span><span class="p">;</span>
        <span class="kn">expires</span> <span class="s">30d</span><span class="p">;</span>
        <span class="kn">add_header</span> <span class="s">Cache-Control</span> <span class="s">"public,</span> <span class="s">immutable"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nginx-설정-활성화">Nginx 설정 활성화</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 심볼릭 링크 생성</span>
<span class="nb">sudo ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/fastapi /etc/nginx/sites-enabled/

<span class="c"># 기본 사이트 비활성화 (선택사항)</span>
<span class="nb">sudo rm</span> /etc/nginx/sites-enabled/default

<span class="c"># 설정 문법 확인</span>
<span class="nb">sudo </span>nginx <span class="nt">-t</span>

<span class="c"># Nginx 재시작</span>
<span class="nb">sudo </span>systemctl reload nginx
</code></pre></div></div>

<h3 id="nginx-고급-설정">Nginx 고급 설정</h3>

<p><strong>Gzip 압축 활성화:</strong></p>

<p><code class="language-plaintext highlighter-rouge">/etc/nginx/nginx.conf</code> 편집:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">http</span> <span class="p">{</span>
    <span class="c1"># Gzip 설정</span>
    <span class="kn">gzip</span> <span class="no">on</span><span class="p">;</span>
    <span class="kn">gzip_vary</span> <span class="no">on</span><span class="p">;</span>
    <span class="kn">gzip_proxied</span> <span class="s">any</span><span class="p">;</span>
    <span class="kn">gzip_comp_level</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kn">gzip_types</span> <span class="nc">text/plain</span> <span class="nc">text/css</span> <span class="nc">text/xml</span> <span class="nc">text/javascript</span>
               <span class="nc">application/json</span> <span class="nc">application/javascript</span> <span class="nc">application/xml</span><span class="s">+rss</span>
               <span class="nc">application/rss</span><span class="s">+xml</span> <span class="nc">font/truetype</span> <span class="nc">font/opentype</span>
               <span class="nc">application/vnd</span><span class="s">.ms-fontobject</span> <span class="nc">image/svg</span><span class="s">+xml</span><span class="p">;</span>
    <span class="kn">gzip_disable</span> <span class="s">"msie6"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Rate Limiting (속도 제한):</strong></p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /etc/nginx/sites-available/fastapi</span>
<span class="k">http</span> <span class="p">{</span>
    <span class="c1"># Rate limit 존 정의</span>
    <span class="kn">limit_req_zone</span> <span class="nv">$binary_remote_addr</span> <span class="s">zone=api_limit:10m</span> <span class="s">rate=10r/s</span><span class="p">;</span>
    
    <span class="kn">server</span> <span class="p">{</span>
        <span class="c1"># ... 기존 설정 ...</span>
        
        <span class="kn">location</span> <span class="n">/api/</span> <span class="p">{</span>
            <span class="kn">limit_req</span> <span class="s">zone=api_limit</span> <span class="s">burst=20</span> <span class="s">nodelay</span><span class="p">;</span>
            <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8000</span><span class="p">;</span>
            <span class="c1"># ... 프록시 설정 ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>보안 헤더 추가:</strong></p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="c1"># ... 기존 설정 ...</span>
    
    <span class="c1"># 보안 헤더</span>
    <span class="kn">add_header</span> <span class="s">X-Frame-Options</span> <span class="s">"SAMEORIGIN"</span> <span class="s">always</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">X-Content-Type-Options</span> <span class="s">"nosniff"</span> <span class="s">always</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">X-XSS-Protection</span> <span class="s">"1</span><span class="p">;</span> <span class="kn">mode=block"</span> <span class="s">always</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">Referrer-Policy</span> <span class="s">"no-referrer-when-downgrade"</span> <span class="s">always</span><span class="p">;</span>
    <span class="kn">add_header</span> <span class="s">Content-Security-Policy</span> <span class="s">"default-src</span> <span class="s">'self'</span> <span class="s">http:</span> <span class="s">https:</span> <span class="s">data:</span> <span class="s">blob:</span> <span class="s">'unsafe-inline'"</span> <span class="s">always</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="systemd-설정-수정">systemd 설정 수정</h3>

<p>Nginx를 사용하는 경우, FastAPI는 로컬호스트에서만 수신:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/systemd/system/fastapi.service
</code></pre></div></div>

<p><strong>ExecStart 수정:</strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app </span><span class="se">\
</span><span class="w">    </span><span class="s">--host 127.0.0.1 </span><span class="se">\ </span><span class="w"> </span><span class="c"># 127.0.0.1로 변경 (0.0.0.0에서)
</span><span class="w">    </span><span class="s">--port 8000 </span><span class="se">\
</span><span class="w">    </span><span class="s">--workers 4</span>
</code></pre></div></div>

<p><strong>서비스 재시작:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl daemon-reload
<span class="nb">sudo </span>systemctl restart fastapi.service
</code></pre></div></div>

<hr />

<h2 id="https-설정-lets-encrypt">HTTPS 설정 (Let’s Encrypt)</h2>

<p>Let’s Encrypt를 사용하여 무료 SSL/TLS 인증서를 발급받고 HTTPS를 설정합니다.</p>

<h3 id="사전-요구사항-1">사전 요구사항</h3>

<ul>
  <li>도메인 이름 (DNS A 레코드가 EC2 IP를 가리켜야 함)</li>
  <li>80, 443 포트가 보안 그룹에서 열려 있어야 함</li>
</ul>

<h3 id="certbot-설치">Certbot 설치</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> certbot python3-certbot-nginx
</code></pre></div></div>

<h3 id="ssl-인증서-발급">SSL 인증서 발급</h3>

<p><strong>자동 설정 (권장):</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>certbot <span class="nt">--nginx</span> <span class="nt">-d</span> your-domain.com <span class="nt">-d</span> www.your-domain.com
</code></pre></div></div>

<p><strong>프롬프트 응답:</strong></p>
<ol>
  <li>이메일 주소 입력 (인증서 만료 알림용)</li>
  <li>이용 약관 동의 (Y)</li>
  <li>HTTPS로 리다이렉트 (권장: 2)</li>
</ol>

<p><strong>수동 설정:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 인증서만 발급 (Nginx 설정은 수동)</span>
<span class="nb">sudo </span>certbot certonly <span class="nt">--nginx</span> <span class="nt">-d</span> your-domain.com <span class="nt">-d</span> www.your-domain.com
</code></pre></div></div>

<h3 id="nginx-https-설정">Nginx HTTPS 설정</h3>

<p>Certbot이 자동으로 설정하지만, 수동 설정이 필요한 경우:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/nginx/sites-available/fastapi
</code></pre></div></div>

<p><strong>HTTPS 설정:</strong></p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># HTTP → HTTPS 리다이렉트</span>
<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">listen</span> <span class="s">[::]:80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">your-domain.com</span> <span class="s">www.your-domain.com</span><span class="p">;</span>
    
    <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$request_uri</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># HTTPS 서버</span>
<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>
    <span class="kn">listen</span> <span class="s">[::]:443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">your-domain.com</span> <span class="s">www.your-domain.com</span><span class="p">;</span>
    
    <span class="c1"># SSL 인증서</span>
    <span class="kn">ssl_certificate</span> <span class="n">/etc/letsencrypt/live/your-domain.com/fullchain.pem</span><span class="p">;</span>
    <span class="kn">ssl_certificate_key</span> <span class="n">/etc/letsencrypt/live/your-domain.com/privkey.pem</span><span class="p">;</span>
    <span class="kn">ssl_trusted_certificate</span> <span class="n">/etc/letsencrypt/live/your-domain.com/chain.pem</span><span class="p">;</span>
    
    <span class="c1"># SSL 설정 (Mozilla Intermediate 기준)</span>
    <span class="kn">ssl_protocols</span> <span class="s">TLSv1.2</span> <span class="s">TLSv1.3</span><span class="p">;</span>
    <span class="kn">ssl_ciphers</span> <span class="s">ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384</span><span class="p">;</span>
    <span class="kn">ssl_prefer_server_ciphers</span> <span class="no">off</span><span class="p">;</span>
    
    <span class="c1"># SSL 세션 캐시</span>
    <span class="kn">ssl_session_cache</span> <span class="s">shared:SSL:10m</span><span class="p">;</span>
    <span class="kn">ssl_session_timeout</span> <span class="mi">10m</span><span class="p">;</span>
    
    <span class="c1"># OCSP Stapling</span>
    <span class="kn">ssl_stapling</span> <span class="no">on</span><span class="p">;</span>
    <span class="kn">ssl_stapling_verify</span> <span class="no">on</span><span class="p">;</span>
    
    <span class="c1"># HSTS (HTTP Strict Transport Security)</span>
    <span class="kn">add_header</span> <span class="s">Strict-Transport-Security</span> <span class="s">"max-age=63072000</span><span class="p">;</span> <span class="kn">includeSubDomains</span><span class="p">;</span> <span class="kn">preload"</span> <span class="s">always</span><span class="p">;</span>
    
    <span class="c1"># 나머지 설정 (프록시, 정적 파일 등)</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8000</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-For</span> <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-Proto</span> <span class="nv">$scheme</span><span class="p">;</span>
        
        <span class="kn">proxy_http_version</span> <span class="mf">1.1</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">"upgrade"</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kn">location</span> <span class="n">/static/</span> <span class="p">{</span>
        <span class="kn">alias</span> <span class="n">/home/ubuntu/reactbase/public/</span><span class="p">;</span>
        <span class="kn">expires</span> <span class="s">30d</span><span class="p">;</span>
        <span class="kn">add_header</span> <span class="s">Cache-Control</span> <span class="s">"public,</span> <span class="s">immutable"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>설정 적용:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nginx <span class="nt">-t</span>
<span class="nb">sudo </span>systemctl reload nginx
</code></pre></div></div>

<h3 id="인증서-자동-갱신">인증서 자동 갱신</h3>

<p>Let’s Encrypt 인증서는 90일마다 갱신이 필요합니다.</p>

<p><strong>자동 갱신 테스트:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>certbot renew <span class="nt">--dry-run</span>
</code></pre></div></div>

<p><strong>자동 갱신 확인:</strong></p>

<p>Certbot은 systemd 타이머로 자동 갱신이 설정됩니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 타이머 상태 확인</span>
<span class="nb">sudo </span>systemctl status certbot.timer

<span class="c"># 갱신 스케줄 확인</span>
<span class="nb">sudo </span>systemctl list-timers | <span class="nb">grep </span>certbot
</code></pre></div></div>

<p><strong>수동 갱신:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>certbot renew
<span class="nb">sudo </span>systemctl reload nginx
</code></pre></div></div>

<h3 id="ssl-등급-테스트">SSL 등급 테스트</h3>

<p><a href="https://www.ssllabs.com/ssltest/">SSL Labs</a>에서 SSL 설정을 테스트하여 A+ 등급을 목표로 합니다.</p>

<hr />

<h2 id="보안-강화">보안 강화</h2>

<h3 id="ufw-방화벽-설정">UFW 방화벽 설정</h3>

<p>UFW(Uncomplicated Firewall)로 호스트 기반 방화벽을 설정합니다.</p>

<p><strong>UFW 설치 및 활성화:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 정책 설정</span>
<span class="nb">sudo </span>ufw default deny incoming
<span class="nb">sudo </span>ufw default allow outgoing

<span class="c"># SSH 허용 (연결 끊김 방지)</span>
<span class="nb">sudo </span>ufw allow 22/tcp
<span class="c"># 또는 특정 IP만</span>
<span class="nb">sudo </span>ufw allow from YOUR_IP_ADDRESS to any port 22

<span class="c"># HTTP/HTTPS 허용</span>
<span class="nb">sudo </span>ufw allow 80/tcp
<span class="nb">sudo </span>ufw allow 443/tcp

<span class="c"># UFW 활성화</span>
<span class="nb">sudo </span>ufw <span class="nb">enable</span>

<span class="c"># 상태 확인</span>
<span class="nb">sudo </span>ufw status verbose
</code></pre></div></div>

<p><strong>8000 포트 차단 (프로덕션):</strong></p>

<p>Nginx를 사용하는 경우 FastAPI 포트를 외부에 노출하지 않습니다:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 8000 포트는 로컬호스트에서만 접근 가능</span>
<span class="c"># UFW 규칙에 8000 포트 추가하지 않음</span>
</code></pre></div></div>

<h3 id="fail2ban-설정">Fail2ban 설정</h3>

<p>SSH 무차별 대입 공격(Brute Force)을 방어합니다.</p>

<p><strong>Fail2ban 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> fail2ban
</code></pre></div></div>

<p><strong>설정 파일 생성:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/fail2ban/jail.local
</code></pre></div></div>

<p><strong>jail.local 내용:</strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[DEFAULT]</span><span class="w">
</span><span class="py">bantime</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">3600  # 1시간 차단</span>
<span class="py">findtime</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">600  # 10분 내</span>
<span class="py">maxretry</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">5    # 5회 시도 실패 시 차단</span>
<span class="w">
</span><span class="c"># SSH 보호
</span><span class="nn">[sshd]</span><span class="w">
</span><span class="py">enabled</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">true</span>
<span class="py">port</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">22</span>
<span class="py">logpath</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">/var/log/auth.log</span>
<span class="w">
</span><span class="c"># Nginx 보호 (선택사항)
</span><span class="nn">[nginx-http-auth]</span><span class="w">
</span><span class="py">enabled</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">true</span>
<span class="py">port</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">http,https</span>
<span class="py">logpath</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">/var/log/nginx/error.log</span>
<span class="w">
</span><span class="nn">[nginx-limit-req]</span><span class="w">
</span><span class="py">enabled</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">true</span>
<span class="py">port</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">http,https</span>
<span class="py">logpath</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">/var/log/nginx/error.log</span>
</code></pre></div></div>

<p><strong>Fail2ban 시작:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">enable </span>fail2ban
<span class="nb">sudo </span>systemctl start fail2ban
<span class="nb">sudo </span>systemctl status fail2ban
</code></pre></div></div>

<p><strong>차단 상태 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 차단된 IP 확인</span>
<span class="nb">sudo </span>fail2ban-client status sshd

<span class="c"># 차단 해제</span>
<span class="nb">sudo </span>fail2ban-client <span class="nb">set </span>sshd unbanip &lt;IP_ADDRESS&gt;
</code></pre></div></div>

<h3 id="ssh-보안-강화">SSH 보안 강화</h3>

<p><strong>SSH 설정 변경:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/ssh/sshd_config
</code></pre></div></div>

<p><strong>권장 설정:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 루트 로그인 비활성화
PermitRootLogin no

# 패스워드 인증 비활성화 (키 기반만 허용)
PasswordAuthentication no
PubkeyAuthentication yes

# 빈 패스워드 금지
PermitEmptyPasswords no

# X11 포워딩 비활성화 (필요없으면)
X11Forwarding no

# 접속 시도 제한
MaxAuthTries 3
MaxSessions 2

# 특정 사용자만 허용
AllowUsers ubuntu
</code></pre></div></div>

<p><strong>SSH 재시작:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl restart sshd
</code></pre></div></div>

<h3 id="자동-보안-업데이트">자동 보안 업데이트</h3>

<p><strong>Unattended-upgrades 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> unattended-upgrades
</code></pre></div></div>

<p><strong>설정:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dpkg-reconfigure <span class="nt">-plow</span> unattended-upgrades
<span class="c"># "Yes" 선택</span>
</code></pre></div></div>

<p><strong>설정 파일 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/apt/apt.conf.d/50unattended-upgrades
</code></pre></div></div>

<p><strong>보안 업데이트만 자동 설치:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}-security";
};
</code></pre></div></div>

<hr />

<h2 id="성능-최적화">성능 최적화</h2>

<h3 id="uvicorn-worker-최적화">Uvicorn Worker 최적화</h3>

<p><strong>Worker 수 설정:</strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /etc/systemd/system/fastapi.service
</span><span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app </span><span class="se">\
</span><span class="w">    </span><span class="s">--host 127.0.0.1 </span><span class="se">\
</span><span class="w">    </span><span class="s">--port 8000 </span><span class="se">\
</span><span class="w">    </span><span class="s">--workers 4  # CPU 코어 수 * 2 + 1</span>
</code></pre></div></div>

<p><strong>Worker 클래스 선택:</strong></p>

<p>기본 Uvicorn worker는 단일 스레드입니다. 높은 동시성이 필요한 경우:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>gunicorn
</code></pre></div></div>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Gunicorn + Uvicorn workers
</span><span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/gunicorn server:app </span><span class="se">\
</span><span class="w">    </span><span class="s">--workers 4 </span><span class="se">\
</span><span class="w">    </span><span class="s">--worker-class uvicorn.workers.UvicornWorker </span><span class="se">\
</span><span class="w">    </span><span class="s">--bind 127.0.0.1:8000 </span><span class="se">\
</span><span class="w">    </span><span class="s">--access-logfile /var/log/fastapi/access.log </span><span class="se">\
</span><span class="w">    </span><span class="s">--error-logfile /var/log/fastapi/error.log</span>
</code></pre></div></div>

<h3 id="데이터베이스-연결-풀링">데이터베이스 연결 풀링</h3>

<p>데이터베이스를 사용하는 경우 연결 풀을 사용합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="n">sqlalchemy.pool</span> <span class="kn">import</span> <span class="n">QueuePool</span>

<span class="n">engine</span> <span class="o">=</span> <span class="nf">create_engine</span><span class="p">(</span>
    <span class="n">DATABASE_URL</span><span class="p">,</span>
    <span class="n">poolclass</span><span class="o">=</span><span class="n">QueuePool</span><span class="p">,</span>
    <span class="n">pool_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">max_overflow</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">pool_pre_ping</span><span class="o">=</span><span class="bp">True</span>  <span class="c1"># 연결 유효성 검사
</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="캐싱-전략">캐싱 전략</h3>

<p><strong>Redis 캐싱 예시:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Redis 설치</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> redis-server
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>redis-server
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
<span class="kn">from</span> <span class="n">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="n">app</span> <span class="o">=</span> <span class="nc">FastAPI</span><span class="p">()</span>
<span class="n">redis_client</span> <span class="o">=</span> <span class="nc">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="sh">'</span><span class="s">localhost</span><span class="sh">'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">decode_responses</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/cached-data</span><span class="sh">"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_cached_data</span><span class="p">():</span>
    <span class="c1"># 캐시 확인
</span>    <span class="n">cached</span> <span class="o">=</span> <span class="n">redis_client</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">data_key</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cached</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">data</span><span class="sh">"</span><span class="p">:</span> <span class="n">cached</span><span class="p">,</span> <span class="sh">"</span><span class="s">source</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">cache</span><span class="sh">"</span><span class="p">}</span>
    
    <span class="c1"># 데이터 조회 및 캐싱
</span>    <span class="n">data</span> <span class="o">=</span> <span class="nf">expensive_operation</span><span class="p">()</span>
    <span class="n">redis_client</span><span class="p">.</span><span class="nf">setex</span><span class="p">(</span><span class="sh">"</span><span class="s">data_key</span><span class="sh">"</span><span class="p">,</span> <span class="mi">3600</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>  <span class="c1"># 1시간 TTL
</span>    <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">data</span><span class="sh">"</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="sh">"</span><span class="s">source</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">database</span><span class="sh">"</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="정적-파일-최적화">정적 파일 최적화</h3>

<p><strong>Nginx에서 직접 서빙:</strong></p>

<p>이미 위에서 설정한 것처럼 Nginx가 정적 파일을 직접 제공합니다.</p>

<p><strong>Gzip 압축:</strong></p>

<p>이미 Nginx에서 설정되었습니다.</p>

<h3 id="메모리-및-cpu-모니터링">메모리 및 CPU 모니터링</h3>

<p><strong>시스템 리소스 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># CPU 및 메모리 사용량</span>
htop
<span class="c"># 또는</span>
top

<span class="c"># 프로세스별 메모리</span>
ps aux <span class="nt">--sort</span><span class="o">=</span>-%mem | <span class="nb">head</span> <span class="nt">-10</span>

<span class="c"># 디스크 사용량</span>
<span class="nb">df</span> <span class="nt">-h</span>

<span class="c"># 네트워크 연결</span>
netstat <span class="nt">-tulpn</span>
</code></pre></div></div>

<hr />

<h2 id="모니터링-및-유지보수">모니터링 및 유지보수</h2>

<h3 id="시스템-모니터링-도구">시스템 모니터링 도구</h3>

<p><strong>htop 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> htop
htop
</code></pre></div></div>

<p><strong>Prometheus + Grafana (고급):</strong></p>

<p>프로덕션 환경에서 권장하는 모니터링 스택:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Prometheus 설치</span>
wget https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz
<span class="nb">tar </span>xvfz prometheus-<span class="k">*</span>.tar.gz
<span class="nb">cd </span>prometheus-<span class="k">*</span>

<span class="c"># 설정 파일 작성</span>
nano prometheus.yml
</code></pre></div></div>

<p><strong>prometheus.yml:</strong></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">global</span><span class="pi">:</span>
  <span class="na">scrape_interval</span><span class="pi">:</span> <span class="s">15s</span>

<span class="na">scrape_configs</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">job_name</span><span class="pi">:</span> <span class="s1">'</span><span class="s">fastapi'</span>
    <span class="na">static_configs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">targets</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">localhost:8000'</span><span class="pi">]</span>
</code></pre></div></div>

<h3 id="애플리케이션-헬스-체크">애플리케이션 헬스 체크</h3>

<p><strong>헬스 체크 엔드포인트 활용:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 주기적으로 헬스 체크</span>
watch <span class="nt">-n</span> 5 curl <span class="nt">-s</span> http://localhost:8000/health
</code></pre></div></div>

<p><strong>Cron 작업으로 자동 모니터링:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-e</span>
</code></pre></div></div>

<pre><code class="language-cron"># 매 5분마다 헬스 체크
*/5 * * * * curl -sf http://localhost:8000/health || systemctl restart fastapi.service
</code></pre>

<h3 id="디스크-공간-모니터링">디스크 공간 모니터링</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디스크 사용량 확인</span>
<span class="nb">df</span> <span class="nt">-h</span>

<span class="c"># 큰 디렉터리 찾기</span>
<span class="nb">du</span> <span class="nt">-h</span> <span class="nt">--max-depth</span><span class="o">=</span>1 /home/ubuntu | <span class="nb">sort</span> <span class="nt">-hr</span>

<span class="c"># 로그 파일 크기 확인</span>
<span class="nb">du</span> <span class="nt">-sh</span> /var/log/<span class="k">*</span>
</code></pre></div></div>

<h3 id="백업-전략">백업 전략</h3>

<p><strong>데이터베이스 백업 (예시):</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># PostgreSQL 백업</span>
pg_dump dbname <span class="o">&gt;</span> backup_<span class="si">$(</span><span class="nb">date</span> +%Y%m%d<span class="si">)</span>.sql

<span class="c"># 백업 자동화 (cron)</span>
0 2 <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> pg_dump dbname <span class="o">&gt;</span> /backup/db_<span class="si">$(</span><span class="nb">date</span> +<span class="se">\%</span>Y<span class="se">\%</span>m<span class="se">\%</span>d<span class="si">)</span>.sql
</code></pre></div></div>

<p><strong>애플리케이션 코드 백업:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Git을 사용한 버전 관리</span>
<span class="nb">cd</span> /home/ubuntu/reactbase
git init
git add <span class="nb">.</span>
git commit <span class="nt">-m</span> <span class="s2">"Initial commit"</span>
git remote add origin &lt;your-repo-url&gt;
git push <span class="nt">-u</span> origin main
</code></pre></div></div>

<h3 id="업데이트-및-배포-전략">업데이트 및 배포 전략</h3>

<p><strong>무중단 배포 (Blue-Green):</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 새 버전 배포</span>
<span class="nb">cd</span> /home/ubuntu/reactbase
git pull origin main

<span class="c"># 의존성 업데이트</span>
<span class="nb">source </span>venv/bin/activate
pip <span class="nb">install</span> <span class="nt">-r</span> requirements.txt

<span class="c"># 서비스 재시작 (짧은 다운타임)</span>
<span class="nb">sudo </span>systemctl restart fastapi.service
</code></pre></div></div>

<p><strong>Graceful Reload:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Gunicorn 사용 시</span>
<span class="nb">sudo </span>systemctl reload fastapi.service
</code></pre></div></div>

<hr />

<h2 id="vscode-sftp-설정">VSCode SFTP 설정</h2>

<p>VSCode를 사용하면 로컬에서 수정한 파일을 자동으로 EC2로 업로드할 수 있습니다.</p>

<h3 id="sftp-익스텐션-설치">SFTP 익스텐션 설치</h3>

<ol>
  <li>VSCode에서 Extensions 열기 (Ctrl+Shift+X)</li>
  <li>“SFTP” 검색 (Natizyskunk.sftp)</li>
  <li>설치</li>
</ol>

<h3 id="sftp-설정-파일-생성">SFTP 설정 파일 생성</h3>

<p>프로젝트 루트에 <code class="language-plaintext highlighter-rouge">.vscode/sftp.json</code> 파일 생성:</p>

<p><strong>Linux/macOS:</strong></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AWS FastAPI Server"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"host"</span><span class="p">:</span><span class="w"> </span><span class="s2">"13.124.216.216"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"protocol"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sftp"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"port"</span><span class="p">:</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w">
    </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ubuntu"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"remotePath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/home/ubuntu/reactbase"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"uploadOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"downloadOnOpen"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"ignore"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">".vscode"</span><span class="p">,</span><span class="w">
        </span><span class="s2">".git"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"venv"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"__pycache__"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"*.pyc"</span><span class="p">,</span><span class="w">
        </span><span class="s2">".env"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"privateKeyPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Windows:</strong></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AWS FastAPI Server"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"host"</span><span class="p">:</span><span class="w"> </span><span class="s2">"13.124.216.216"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"protocol"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sftp"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"port"</span><span class="p">:</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w">
    </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ubuntu"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"remotePath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/home/ubuntu/reactbase"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"uploadOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"downloadOnOpen"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"ignore"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">".vscode"</span><span class="p">,</span><span class="w">
        </span><span class="s2">".git"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"venv"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"__pycache__"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"*.pyc"</span><span class="p">,</span><span class="w">
        </span><span class="s2">".env"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"privateKeyPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C:</span><span class="se">\\</span><span class="s2">Users</span><span class="se">\\</span><span class="s2">my</span><span class="se">\\\p</span><span class="s2">em</span><span class="se">\\</span><span class="s2">my_proton_key.pem"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>중요 설정 옵션:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">uploadOnSave</code>: 파일 저장 시 자동 업로드</li>
  <li><code class="language-plaintext highlighter-rouge">downloadOnOpen</code>: 파일 열 때 서버에서 다운로드</li>
  <li><code class="language-plaintext highlighter-rouge">ignore</code>: 업로드 제외 파일/폴더</li>
  <li><code class="language-plaintext highlighter-rouge">privateKeyPath</code>: Windows에서는 <code class="language-plaintext highlighter-rouge">\\\\</code> 사용 (이스케이프)</li>
</ul>

<h3 id="sftp-사용법">SFTP 사용법</h3>

<p><strong>파일 업로드:</strong></p>

<ul>
  <li>파일 저장 시 자동 업로드 (uploadOnSave: true)</li>
  <li>수동 업로드: F1 → “SFTP: Upload” 선택</li>
</ul>

<p><strong>폴더 동기화:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F1 → "SFTP: Sync Local -&gt; Remote"
F1 → "SFTP: Sync Remote -&gt; Local"
</code></pre></div></div>

<p><strong>서버 파일 직접 편집:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F1 → "SFTP: List"
파일 선택 → 편집
</code></pre></div></div>

<h3 id="배포-후-서비스-재시작">배포 후 서비스 재시작</h3>

<p>파일 업로드 후 서버에서:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SSH 접속</span>
ssh aws-fastapi

<span class="c"># 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service

<span class="c"># 로그 확인</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-f</span>
</code></pre></div></div>

<hr />

<h2 id="트러블슈팅">트러블슈팅</h2>

<h3 id="포트-접속-불가-문제">포트 접속 불가 문제</h3>

<p><strong>증상:</strong>
브라우저에서 <code class="language-plaintext highlighter-rouge">http://인스턴스IP:8000</code> 접속 불가</p>

<p><strong>진단 단계:</strong></p>

<ol>
  <li><strong>서비스 실행 확인:</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl status fastapi.service
ps aux | <span class="nb">grep </span>uvicorn
</code></pre></div></div>

<ol>
  <li><strong>포트 리스닝 확인:</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>netstat <span class="nt">-tulpn</span> | <span class="nb">grep</span> :8000
<span class="c"># 또는</span>
<span class="nb">sudo </span>ss <span class="nt">-tulpn</span> | <span class="nb">grep</span> :8000
</code></pre></div></div>

<ol>
  <li><strong>로컬호스트 접근 테스트:</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://localhost:8000
curl http://127.0.0.1:8000
</code></pre></div></div>

<ol>
  <li><strong>AWS 보안 그룹 확인:</strong></li>
</ol>

<p>EC2 Console → 보안 그룹 → 인바운드 규칙에 8000 포트 있는지 확인</p>

<ol>
  <li><strong>UFW 방화벽 확인:</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ufw status
<span class="c"># 8000 포트가 허용되어 있는지 확인</span>
</code></pre></div></div>

<ol>
  <li><strong>ISP 방화벽 문제:</strong></li>
</ol>

<p>집 인터넷에서 안 되면 <strong>휴대폰 핫스팟</strong>으로 시도</p>

<p><strong>해결 방법:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 보안 그룹에 8000 포트 추가</span>
<span class="c"># UFW 허용 (필요한 경우)</span>
<span class="nb">sudo </span>ufw allow 8000/tcp

<span class="c"># 서비스 재시작</span>
<span class="nb">sudo </span>systemctl restart fastapi.service
</code></pre></div></div>

<h3 id="systemd-서비스-실행-실패">systemd 서비스 실행 실패</h3>

<p><strong>증상:</strong>
<code class="language-plaintext highlighter-rouge">sudo systemctl start fastapi.service</code> 실패</p>

<p><strong>진단:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상세 로그 확인</span>
<span class="nb">sudo </span>journalctl <span class="nt">-u</span> fastapi.service <span class="nt">-xe</span>

<span class="c"># 서비스 파일 문법 확인</span>
systemd-analyze verify /etc/systemd/system/fastapi.service

<span class="c"># 수동 실행 테스트</span>
<span class="nb">cd</span> /home/ubuntu/reactbase
<span class="nb">source </span>venv/bin/activate
python3 server.py
</code></pre></div></div>

<p><strong>일반적인 원인:</strong></p>

<ol>
  <li><strong>가상환경 경로 오류:</strong></li>
</ol>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 경로 확인
</span><span class="py">Environment</span><span class="p">=</span><span class="s">"PATH=/home/ubuntu/reactbase/venv/bin"</span>
<span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app</span>
</code></pre></div></div>

<ol>
  <li><strong>파일 권한 문제:</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo chown</span> <span class="nt">-R</span> ubuntu:ubuntu /home/ubuntu/reactbase
<span class="nb">chmod </span>755 /home/ubuntu/reactbase
</code></pre></div></div>

<ol>
  <li><strong>모듈 누락:</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source </span>venv/bin/activate
pip <span class="nb">install </span>fastapi uvicorn
</code></pre></div></div>

<h3 id="permission-denied-오류">Permission Denied 오류</h3>

<p><strong>증상:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PermissionError: [Errno 13] Permission denied: '/some/path'
</code></pre></div></div>

<p><strong>해결:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디렉터리 소유자 확인</span>
<span class="nb">ls</span> <span class="nt">-la</span> /home/ubuntu/reactbase

<span class="c"># 소유자 변경</span>
<span class="nb">sudo chown</span> <span class="nt">-R</span> ubuntu:ubuntu /home/ubuntu/reactbase

<span class="c"># 권한 설정</span>
<span class="nb">chmod </span>755 /home/ubuntu/reactbase
<span class="nb">chmod </span>644 /home/ubuntu/reactbase/server.py
<span class="nb">chmod </span>600 /home/ubuntu/reactbase/.env
</code></pre></div></div>

<h3 id="메모리-부족-문제">메모리 부족 문제</h3>

<p><strong>증상:</strong>
서버가 자주 재시작되거나 응답이 느림</p>

<p><strong>진단:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 메모리 사용량 확인</span>
free <span class="nt">-h</span>

<span class="c"># 프로세스별 메모리</span>
ps aux <span class="nt">--sort</span><span class="o">=</span>-%mem | <span class="nb">head</span> <span class="nt">-10</span>

<span class="c"># OOM (Out of Memory) 로그 확인</span>
dmesg | <span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"out of memory"</span>
<span class="nb">sudo </span>journalctl <span class="nt">-k</span> | <span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"killed process"</span>
</code></pre></div></div>

<p><strong>해결:</strong></p>

<ol>
  <li><strong>Worker 수 줄이기:</strong></li>
</ol>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /etc/systemd/system/fastapi.service
</span><span class="py">ExecStart</span><span class="p">=</span><span class="s">/home/ubuntu/reactbase/venv/bin/uvicorn server:app </span><span class="se">\
</span><span class="w">    </span><span class="s">--workers 2  # 줄임</span>
</code></pre></div></div>

<ol>
  <li><strong>스왑 메모리 추가:</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1GB 스왑 생성</span>
<span class="nb">sudo </span>fallocate <span class="nt">-l</span> 1G /swapfile
<span class="nb">sudo chmod </span>600 /swapfile
<span class="nb">sudo </span>mkswap /swapfile
<span class="nb">sudo </span>swapon /swapfile

<span class="c"># 영구 설정</span>
<span class="nb">echo</span> <span class="s1">'/swapfile none swap sw 0 0'</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/fstab

<span class="c"># 확인</span>
free <span class="nt">-h</span>
</code></pre></div></div>

<ol>
  <li><strong>인스턴스 업그레이드:</strong> t2.micro → t2.small</li>
</ol>

<h3 id="네트워크-타임아웃">네트워크 타임아웃</h3>

<p><strong>증상:</strong>
요청이 느리거나 타임아웃</p>

<p><strong>해결:</strong></p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Nginx 타임아웃 증가</span>
<span class="k">location</span> <span class="n">/</span> <span class="p">{</span>
    <span class="kn">proxy_connect_timeout</span> <span class="s">120s</span><span class="p">;</span>
    <span class="kn">proxy_send_timeout</span> <span class="s">120s</span><span class="p">;</span>
    <span class="kn">proxy_read_timeout</span> <span class="s">120s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># systemd 타임아웃
</span><span class="nn">[Service]</span><span class="w">
</span><span class="py">TimeoutStartSec</span><span class="p">=</span><span class="s">120</span>
<span class="py">TimeoutStopSec</span><span class="p">=</span><span class="s">120</span>
</code></pre></div></div>

<h3 id="sftp-연결-문제">SFTP 연결 문제</h3>

<p><strong>Windows에서 privateKeyPath 오류:</strong></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"privateKeyPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C:</span><span class="se">\\</span><span class="s2">Users</span><span class="se">\\</span><span class="s2">my</span><span class="se">\\\p</span><span class="s2">em</span><span class="se">\\</span><span class="s2">my_proton_key.pem"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>키 권한 오류:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Linux/macOS</span>
<span class="nb">chmod </span>400 /path/to/key.pem

<span class="c"># Windows PowerShell</span>
icacls <span class="s2">"C:</span><span class="se">\p</span><span class="s2">ath</span><span class="se">\t</span><span class="s2">o</span><span class="se">\k</span><span class="s2">ey.pem"</span> /inheritance:r
icacls <span class="s2">"C:</span><span class="se">\p</span><span class="s2">ath</span><span class="se">\t</span><span class="s2">o</span><span class="se">\k</span><span class="s2">ey.pem"</span> /grant:r <span class="s2">"%USERNAME%:R"</span>
</code></pre></div></div>

<p><strong>연결 테스트:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널에서 SFTP 테스트</span>
sftp <span class="nt">-i</span> /path/to/key.pem ubuntu@&lt;IP&gt;
</code></pre></div></div>

<hr />

<h2 id="참고-자료">참고 자료</h2>

<h3 id="공식-문서">공식 문서</h3>

<p><strong>FastAPI:</strong></p>
<ul>
  <li><a href="https://fastapi.tiangolo.com/">FastAPI 공식 문서</a></li>
  <li><a href="https://fastapi.tiangolo.com/deployment/">FastAPI 배포 가이드</a></li>
  <li><a href="https://www.uvicorn.org/">Uvicorn 문서</a></li>
</ul>

<p><strong>AWS:</strong></p>
<ul>
  <li><a href="https://docs.aws.amazon.com/ec2/">EC2 사용 설명서</a></li>
  <li><a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html">보안 그룹 규칙</a></li>
  <li><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP 주소</a></li>
</ul>

<p><strong>Nginx:</strong></p>
<ul>
  <li><a href="https://nginx.org/en/docs/">Nginx 공식 문서</a></li>
  <li><a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">Nginx 리버스 프록시 가이드</a></li>
</ul>

<p><strong>Let’s Encrypt:</strong></p>
<ul>
  <li><a href="https://certbot.eff.org/">Certbot 문서</a></li>
  <li><a href="https://letsencrypt.org/docs/">Let’s Encrypt 문서</a></li>
</ul>

<p><strong>systemd:</strong></p>
<ul>
  <li><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">systemd 서비스 단위 파일</a></li>
  <li><a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">systemd 예제</a></li>
</ul>

<h3 id="보안-best-practices">보안 Best Practices</h3>

<ul>
  <li><a href="https://owasp.org/www-project-top-ten/">OWASP Top 10</a></li>
  <li><a href="https://ssl-config.mozilla.org/">Mozilla SSL Configuration Generator</a></li>
  <li><a href="https://www.cisecurity.org/benchmark/ubuntu_linux">CIS Ubuntu Benchmark</a></li>
</ul>

<h3 id="성능-최적화-1">성능 최적화</h3>

<ul>
  <li><a href="https://fastapi.tiangolo.com/advanced/performance/">FastAPI 성능 팁</a></li>
  <li><a href="https://www.uvicorn.org/deployment/">Uvicorn 프로덕션 배포</a></li>
  <li><a href="https://www.nginx.com/blog/tuning-nginx/">Nginx 성능 튜닝</a></li>
</ul>

<h3 id="모니터링-도구">모니터링 도구</h3>

<ul>
  <li><a href="https://prometheus.io/">Prometheus</a></li>
  <li><a href="https://grafana.com/">Grafana</a></li>
  <li><a href="https://www.netdata.cloud/">Netdata</a></li>
  <li><a href="https://aws.amazon.com/cloudwatch/">CloudWatch (AWS)</a></li>
</ul>

<h3 id="커뮤니티">커뮤니티</h3>

<ul>
  <li><a href="https://github.com/tiangolo/fastapi">FastAPI GitHub</a></li>
  <li><a href="https://discord.com/invite/VQjSZaeJmf">FastAPI Discord</a></li>
  <li><a href="https://stackoverflow.com/questions/tagged/fastapi">Stack Overflow - FastAPI 태그</a></li>
</ul>

<hr />

<h2 id="마무리">마무리</h2>

<p>이 문서는 AWS EC2에서 FastAPI 애플리케이션을 프로덕션 수준으로 배포하는 완전한 가이드를 제공합니다.</p>

<p><strong>핵심 단계 요약:</strong></p>

<ol>
  <li><strong>인프라 설정</strong>: EC2 인스턴스 생성 및 보안 그룹 구성</li>
  <li><strong>애플리케이션 배포</strong>: Python 환경 설정 및 FastAPI 설치</li>
  <li><strong>프로세스 관리</strong>: systemd를 통한 자동 실행 및 관리</li>
  <li><strong>리버스 프록시</strong>: Nginx를 통한 트래픽 라우팅 및 최적화</li>
  <li><strong>보안 강화</strong>: HTTPS, 방화벽, Fail2ban 설정</li>
  <li><strong>성능 최적화</strong>: Worker 설정, 캐싱, 리소스 모니터링</li>
  <li><strong>지속적 관리</strong>: 로그 관리, 백업, 업데이트 전략</li>
</ol>

<p><strong>프로덕션 체크리스트:</strong></p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />systemd 자동 실행 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Nginx 리버스 프록시 구성</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />HTTPS/SSL 인증서 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />UFW 방화벽 활성화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Fail2ban SSH 보호</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />로그 로테이션 설정</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />헬스 체크 엔드포인트 구현</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />모니터링 도구 설치</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />백업 전략 수립</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />자동 보안 업데이트 활성화</li>
</ul>

<p>이제 여러분의 FastAPI 서버는 안정적이고 안전하며 확장 가능한 프로덕션 환경에서 실행됩니다.</p>

<p><strong>추가 개선 사항:</strong></p>

<ul>
  <li>CI/CD 파이프라인 구축 (GitHub Actions, GitLab CI)</li>
  <li>컨테이너화 (Docker, Docker Compose)</li>
  <li>오케스트레이션 (Kubernetes, ECS)</li>
  <li>로드 밸런서 구성 (Application Load Balancer)</li>
  <li>데이터베이스 분리 (RDS, Aurora)</li>
  <li>CDN 활용 (CloudFront)</li>
  <li>서버리스 옵션 (Lambda + API Gateway)</li>
</ul>

<p>행운을 빕니다!</p>]]></content><author><name>DevOps Engineer</name></author><category term="Learning" /><category term="FastAPI" /><category term="EC2" /><category term="Ubuntu" /><category term="systemd" /><category term="Python" /><category term="서버배포" /><category term="자동실행" /><category term="SFTP" /><category term="Nginx" /><category term="HTTPS" /><category term="Security" /><category term="DevOps" /><category term="Backend" /><summary type="html"><![CDATA[AWS EC2 Ubuntu 환경에서 FastAPI 애플리케이션을 프로덕션 수준으로 배포하는 완전한 기술 레퍼런스. systemd 자동 실행, Nginx 리버스 프록시, HTTPS 설정, 보안 강화, 성능 최적화, 모니터링까지 포함.]]></summary></entry><entry><title type="html">경쟁자가 Reddit 모더레이터가 되어 2,350만 달러 부트캠프를 무너뜨린 사건</title><link href="http://localhost:4000/my-blog/qa%20engineer/2025/10/10/reddit-2350.html" rel="alternate" type="text/html" title="경쟁자가 Reddit 모더레이터가 되어 2,350만 달러 부트캠프를 무너뜨린 사건" /><published>2025-10-10T00:02:05+09:00</published><updated>2025-10-10T00:02:05+09:00</updated><id>http://localhost:4000/my-blog/qa%20engineer/2025/10/10/reddit---2350</id><content type="html" xml:base="http://localhost:4000/my-blog/qa%20engineer/2025/10/10/reddit-2350.html"><![CDATA[<h2 id="요약">요약</h2>

<p>경쟁자가 Reddit의 주요 서브레딧을 통제함으로써 Codesmith의 평판이 크게 훼손되었으며, 이로 인해 부정적인 내러티브가 확산되고 구글 검색 결과에도 영향을 미쳤습니다. 이 사건은 온라인 플랫폼에서의 평판 관리의 중요성을 강조합니다.</p>

<h2 id="qa-engineer가-알아야-할-핵심-내용">QA Engineer가 알아야 할 핵심 내용</h2>

<ul>
  <li>이 사건은 QA 엔지니어들에게 온라인 평판 관리의 중요성을 일깨워 주며, 소셜 미디어와 커뮤니티의 영향력을 이해하는 것이 필수적임을 보여줍니다.</li>
  <li>부정적인 내러티브가 제품이나 서비스의 품질에 대한 인식을 어떻게 변화시킬 수 있는지를 고려해야 하며, 이를 테스트 전략에 반영해야 합니다.</li>
  <li>QA 업무에서 소셜 미디어와 사용자 피드백을 모니터링하여 잠재적인 문제를 조기에 발견하고 대응할 수 있는 체계를 마련해야 합니다.</li>
</ul>

<h2 id="실무-적용-가이드">실무 적용 가이드</h2>

<h3 id="1-테스트-자동화-개선">1. 테스트 자동화 개선</h3>

<p>부정적인 사용자 피드백을 반영하여 테스트 자동화를 개선하는 방안</p>

<p><strong>실행 단계:</strong></p>
<ul>
  <li>
    <ol>
      <li>사용자 피드백 및 리뷰를 분석하여 주요 문제점을 도출합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>도출된 문제점을 기반으로 새로운 테스트 케이스를 작성합니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>기존 자동화 스크립트를 업데이트하여 새로운 테스트 케이스를 포함시킵니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>테스트 자동화를 실행하고 결과를 분석하여 품질 개선 사항을 도출합니다.</li>
    </ol>
  </li>
</ul>

<h3 id="2-품질-검증-프로세스">2. 품질 검증 프로세스</h3>

<p>부정적인 내러티브를 사전에 차단하기 위한 품질 검증 프로세스를 수립합니다.</p>

<h2 id="학습-로드맵">학습 로드맵</h2>

<h3 id="즉시-학습-1-2주">즉시 학습 (1-2주)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>소셜 미디어 분석</li>
  <li>사용자 피드백 수집</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>소셜 미디어 분석 툴 튜토리얼</li>
  <li>사용자 피드백 수집 방법</li>
</ul>

<h3 id="단기-학습-1-3개월">단기 학습 (1-3개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>위기 관리 전략</li>
  <li>온라인 평판 관리</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>위기 관리 관련 서적</li>
  <li>온라인 평판 관리 워크숍</li>
</ul>

<h3 id="장기-학습-3-6개월">장기 학습 (3-6개월)</h3>

<p><strong>배워야 할 기술:</strong></p>
<ul>
  <li>데이터 분석 및 시각화</li>
  <li>고급 테스트 자동화</li>
</ul>

<p><strong>추천 학습 자료:</strong></p>
<ul>
  <li>고급 데이터 분석 과정</li>
  <li>테스트 자동화 고급 기술</li>
</ul>

<h2 id="전문가-의견">전문가 의견</h2>

<h3 id="시니어-qa-엔지니어-관점">시니어 QA 엔지니어 관점</h3>

<blockquote>
  <p>온라인 커뮤니티에서의 평판은 제품의 성공에 큰 영향을 미치므로, QA 팀은 이를 적극적으로 모니터링하고 대응할 필요가 있습니다.</p>
</blockquote>

<h3 id="테스트-자동화-전문가-관점">테스트 자동화 전문가 관점</h3>

<blockquote>
  <p>부정적인 사용자 피드백을 반영한 테스트 자동화는 제품 품질 향상에 기여할 수 있으며, 이를 위해 지속적인 피드백 루프를 구축해야 합니다.</p>
</blockquote>

<h3 id="devopssre-관점">DevOps/SRE 관점</h3>

<blockquote>
  <p>운영 안정성을 위해서는 사용자 피드백을 기반으로 한 지속적인 개선이 필요하며, 이를 위해 QA와 DevOps 팀 간의 협력이 필수적입니다.</p>
</blockquote>

<h2 id="주요-qa">주요 Q&amp;A</h2>

<p><strong>Q:</strong> 이 기술의 핵심 변화는 무엇인가요?</p>

<p><strong>A:</strong> 경쟁자가 Reddit 서브레딧을 통제함으로써 부정적인 내러티브가 확산되었고, 이는 기업의 평판과 검색 결과에 직접적인 영향을 미쳤습니다.</p>

<p><strong>Q:</strong> QA 담당자가 확인해야 할 위험 요소는?</p>

<p><strong>A:</strong> 부정적인 사용자 피드백, 소셜 미디어에서의 부정적 언급, 그리고 검색 엔진 결과에서의 평판 저하 등이 주요 위험 요소입니다.</p>

<p><strong>Q:</strong> 팀에 바로 적용할 수 있는 행동 항목은?</p>

<p><strong>A:</strong> 소셜 미디어 모니터링 도구를 도입하고, 사용자 피드백을 정기적으로 분석하여 품질 개선에 반영하는 프로세스를 구축해야 합니다.</p>

<h2 id="follow-up-제안">Follow-up 제안</h2>

<ul>
  <li>소셜 미디어와 커뮤니티에서의 평판 관리 전략</li>
  <li>부정적인 내러티브 대응 방안</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://www.reddit.com/r/faq">공식 문서</a></li>
  <li><a href="https://www.udemy.com/course/social-media-analysis/">튜토리얼</a></li>
</ul>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="QA Engineer" /><category term="qa" /><category term="reputation-management" /><category term="online-platform" /><category term="risk-management" /><category term="case-study" /><summary type="html"><![CDATA[온라인 플랫폼에서의 평판 관리와 리스크 관리의 중요성을 보여주는 Codesmith 사례 분석]]></summary></entry><entry><title type="html">70,000명 Discord 사용자의 신분증 정보 유출 가능성</title><link href="http://localhost:4000/my-blog/qa%20engineer/2025/10/09/70000-discord.html" rel="alternate" type="text/html" title="70,000명 Discord 사용자의 신분증 정보 유출 가능성" /><published>2025-10-09T23:28:44+09:00</published><updated>2025-10-09T23:28:44+09:00</updated><id>http://localhost:4000/my-blog/qa%20engineer/2025/10/09/70000-discord</id><content type="html" xml:base="http://localhost:4000/my-blog/qa%20engineer/2025/10/09/70000-discord.html"><![CDATA[<h2 id="요약">요약</h2>

<p>Discord는 서드파티 고객지원 업체의 보안 사고로 인해 약 70,000명의 사용자의 정부 발급 신분증 사진이 노출될 가능성이 있다고 발표했습니다. 이번 사고는 Discord의 자체 시스템이 아닌 외부 서비스 공급자에서 발생하였으며, 공격자는 실제 피해 규모보다 더 큰 영향을 미쳤다고 주장하고 있습니다.</p>

<h2 id="주요-qa">주요 Q&amp;A</h2>

<ul>
  <li>
    <p><strong>Q:</strong> 이번 보안 사고의 원인은 무엇인가요?
<strong>A:</strong> 서드파티 고객지원 업체의 보안 사고로 인해 발생했습니다.</p>
  </li>
  <li>
    <p><strong>Q:</strong> 유출된 정보의 종류는 무엇인가요?
<strong>A:</strong> 정부 발급 신분증 사진이 유출될 가능성이 있습니다.</p>
  </li>
  <li>
    <p><strong>Q:</strong> Discord의 자체 시스템에서 발생한 사고인가요?
<strong>A:</strong> 아니요, 이번 사고는 Discord의 자체 시스템이 아닌 외부 서비스 공급자에서 발생했습니다.</p>
  </li>
  <li>
    <p><strong>Q:</strong> 피해 규모는 얼마나 되나요?
<strong>A:</strong> 약 70,000명의 사용자 정보가 노출될 가능성이 있습니다.</p>
  </li>
</ul>

<h2 id="follow-up-제안">Follow-up 제안</h2>

<ul>
  <li>서드파티 고객지원 업체의 보안 강화 방안 조사</li>
  <li>유출된 정보의 실제 피해 규모 확인</li>
  <li>Discord의 보안 정책 및 외부 서비스 관리 방안 검토</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://news.hada.io/topic?id=23539">Hada News</a></li>
</ul>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="QA Engineer" /><category term="security" /><category term="discord" /><category term="data-breach" /><category term="qa" /><category term="third-party-risk" /><summary type="html"><![CDATA[Discord 서드파티 고객지원 업체의 보안 사고로 인한 신분증 정보 유출 가능성과 QA 관점의 분석]]></summary></entry><entry><title type="html">DIY - 다양한 DIY 프로젝트 안내 및 팁</title><link href="http://localhost:4000/my-blog/daily%20life/2025/09/25/diy-guide-and-tips.html" rel="alternate" type="text/html" title="DIY - 다양한 DIY 프로젝트 안내 및 팁" /><published>2025-09-25T17:01:36+09:00</published><updated>2025-09-25T17:01:36+09:00</updated><id>http://localhost:4000/my-blog/daily%20life/2025/09/25/diy-guide-and-tips</id><content type="html" xml:base="http://localhost:4000/my-blog/daily%20life/2025/09/25/diy-guide-and-tips.html"><![CDATA[<h1 id="diy-다양한-diy-프로젝트-안내-및-팁">DIY: 다양한 DIY 프로젝트 안내 및 팁</h1>

<p>DIY(Do It Yourself)는 스스로 만들고 수리하는 것을 의미합니다. 일상 생활에서 자신만의 창의성을 발휘할 수 있는 좋은 방법입니다. 이번 글에서는 DIY의 개념과 여러 가지 DIY 프로젝트 아이디어, 그리고 유용한 팁에 대해 자세히 알아보겠습니다.</p>

<h2 id="diy의-장점">DIY의 장점</h2>

<p>DIY는 단순한 취미 이상의 의미가 있습니다. DIY를 통해 우리는 여러 가지 장점을 얻을 수 있습니다:</p>

<ol>
  <li><strong>창의성 발휘</strong>: 스스로 아이디어를 내고 결과물을 만드는 과정에서 큰 창의성을 느낄 수 있습니다.</li>
  <li><strong>비용 절감</strong>: 상점에서 구매하는 것보다 자재를 구매하고 직접 만드는 것이 훨씬 저렴할 수 있습니다.</li>
  <li><strong>개인화</strong>: 원하는 형태와 디자인으로 만들어질 수 있기 때문에, 유니크한 아이템을 갖는 것이 가능합니다.</li>
  <li><strong>성취감</strong>: 스스로 작업을 마무리했을 때의 성취감은 무엇과도 비교할 수 없는 만족을 줍니다.</li>
</ol>

<h2 id="diy-프로젝트-아이디어">DIY 프로젝트 아이디어</h2>

<p>이제 몇 가지 흥미로운 DIY 프로젝트를 소개하겠습니다. 각 프로젝트는 초보자부터 전문가까지 다양하게 즐길 수 있습니다.</p>

<h3 id="1-꽃다발-만들기">1. 꽃다발 만들기</h3>

<h4 id="필요한-재료">필요한 재료:</h4>
<ul>
  <li>다양한 색상의 꽃</li>
  <li>꽃 방울</li>
  <li>수건</li>
  <li>플로럴 테이프</li>
</ul>

<h4 id="만드는-방법">만드는 방법:</h4>
<ol>
  <li>꽃을 적당한 길이로 자릅니다.</li>
  <li>원하시는 조합으로 꽃을 배열합니다.</li>
  <li>방울을 사용하여 꽃을 엮습니다.</li>
  <li>플로럴 테이프로 단단히 고정합니다.</li>
  <li>원하시는 스타일로 마무리합니다.</li>
</ol>

<p>이 프로젝트는 친구에게 선물하거나 특별한 날을 기념하는 데 아주 적합합니다.</p>

<h3 id="2-샌들-리폼하기">2. 샌들 리폼하기</h3>

<p>오래된 샌들을 새롭게 변화시키는 방법입니다. 이 DIY 프로젝트는 환경을 생각한 업사이클링의 일환으로 진행할 수 있습니다.</p>

<h4 id="필요한-재료-1">필요한 재료:</h4>
<ul>
  <li>낡은 샌들</li>
  <li>천 조각</li>
  <li>접착제</li>
  <li>가위</li>
</ul>

<h4 id="만드는-방법-1">만드는 방법:</h4>
<ol>
  <li>낡은 샌들의 이용하지 않는 부분을 잘라냅니다.</li>
  <li>원하는 모양과 크기로 천 조각을 자릅니다.</li>
  <li>접착제를 사용하여 천 조각을 샌들에 붙입니다.</li>
  <li>건조시간을 충분히 두고 사용합니다.</li>
</ol>

<p>이러한 DIY 리폼 프로젝트가 좋은 이유는, 사용하지 않던 물품을 새롭게 태어나게 할 수 있기 때문입니다.</p>

<h3 id="3-가구-재단장">3. 가구 재단장</h3>

<p>오래된 가구를 새롭게 변신시키는 것도 훌륭한 DIY 프로젝트입니다. 필요한 자재로는 샌딩 블록, 페인트, 브러시 등이 있습니다.</p>

<ol>
  <li>가구를 깨끗이 청소한 후, 표면을 샌딩하여 매끄럽게 합니다.</li>
  <li>원하는 색상의 페인트를 사용하여 여러 번 칠해줍니다.</li>
  <li>완전히 건조된 후, 필요에 따라 방수 처리를 합니다.</li>
</ol>

<p>이런 방법으로 재단장한 가구는 집안의 분위기를 완전히 바꿔놓습니다.</p>

<h2 id="diy-팁">DIY 팁</h2>

<p>DIY 프로젝트는 신중함이 필요합니다. 다음은 몇 가지 유용한 팁입니다:</p>
<ul>
  <li><strong>설계 단계</strong>: 프로젝트를 시작하기 전에 반드시 설계도를 작성하세요. 명확한 계획이 성공적인 DIY의 첫걸음입니다.</li>
  <li><strong>올바른 도구 선택</strong>: 필요한 도구와 자재는 미리 준비하여 작업 시간을 단축시킬 수 있습니다.</li>
  <li><strong>여유 있는 시간</strong>: 서두르지 말고 작업을 진행하세요. 각 단계의 마무리에 신경을 쓰는 것이 좋습니다.</li>
  <li><strong>실수는 괜찮아</strong>: 처음부터 모든 것을 완벽하게 할 필요는 없습니다. 실수를 통해 배운다면 더욱 좋은 경험이 될 것입니다.</li>
</ul>

<h2 id="결론">결론</h2>

<p>DIY는 시간과 노력을 요구하지만, 그 보상은 언제나 당신의 기대 이상입니다. 창의성이 발휘되는 한편, 실용적인 결과물을 만들어 낼 수 있습니다. 이제 여러분도 DIY 프로젝트에 도전해 보세요! 주말을 알차게 보내고, 스스로 만든 작품으로 자부심을 느낄 수 있을 것입니다.</p>

<p>이 글을 통해 DIY라는 주제가 얼마나 흥미롭고 유익한지 느끼셨기를 바랍니다. 도전하고, 배우고, 성장하는 즐거운 여정을 시작해보세요!</p>]]></content><author><name>류정현</name><email>jhryu115@gmail.com</email></author><category term="Daily Life" /><category term="diy" /><category term="handmade" /><category term="crafts" /><category term="hobby" /><category term="tips" /><summary type="html"><![CDATA[집에서 즐길 수 있는 다양한 DIY 프로젝트와 실용적인 팁]]></summary></entry></feed>